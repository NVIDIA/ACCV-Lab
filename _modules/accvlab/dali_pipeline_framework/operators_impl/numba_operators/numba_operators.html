

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>accvlab.dali_pipeline_framework.operators_impl.numba_operators.numba_operators &mdash; ACCV-Lab 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/custom.css?v=9282052d" />

  
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            ACCV-Lab
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">General Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../project_overview/README.html">ACCV-Lab Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../guides_index.html">Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contained Packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contained_package_docs_mirror/on_demand_video_decoder/docs/index.html">On Demand Video Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contained_package_docs_mirror/batching_helpers/docs/index.html">Batching Helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/index.html">DALI Pipeline Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contained_package_docs_mirror/draw_heatmap/docs/index.html">Draw Heatmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contained_package_docs_mirror/optim_test_tools/docs/index.html">Optimization Testing Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">ACCV-Lab</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">accvlab.dali_pipeline_framework.operators_impl.numba_operators.numba_operators</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for accvlab.dali_pipeline_framework.operators_impl.numba_operators.numba_operators</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2025, NVIDIA CORPORATION &amp; AFFILIATES. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.plugin.numba.fn.experimental</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fnex</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.fn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">nvidia.dali</span><span class="w"> </span><span class="kn">import</span> <span class="n">types</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">nvidia.dali.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">do_not_convert</span><span class="p">,</span> <span class="n">DataNode</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>


<div class="viewcode-block" id="pad_to_size">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.pad_to_size">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pad_to_size</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Pad input data to a specified size along the first dimension (i.e. ``dim==0``).</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        input: Data to pad.</span>
<span class="sd">        num_dims: Number of dimensions in the data.</span>
<span class="sd">        data_type: Data type of the input data.</span>
<span class="sd">        size: Target size to pad the first dimension (i.e. ``dim==0``) to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Padded data with the specified size.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_pad_to_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_pad_to_size</span><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">in0</span><span class="p">):</span>
        <span class="n">numel_fill</span> <span class="o">=</span> <span class="n">in0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">in0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="k">else</span> <span class="n">size</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numel_fill</span><span class="p">):</span>
            <span class="n">out0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">in0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">out0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">assert</span> <span class="n">num_dims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;num_dims must be greater than 0&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="nb">input</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">run_pad_to_size</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_pad_to_size</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="remove_inactive">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.remove_inactive">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_inactive</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">active_mask</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">masked_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Remove inactive elements in the data.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        data: Data to process.</span>
<span class="sd">        active_mask: Boolean mask indicating which elements are active.</span>
<span class="sd">        masked_dimension: The dimension of the data along which the elements are located, i.e. where each</span>
<span class="sd">            index indicates another element. The mask will be applied in this dimension and its size must</span>
<span class="sd">            match the mask size.</span>
<span class="sd">        num_dims: The overall number of dimensions in ``data``.</span>
<span class="sd">        data_type: Data type of the data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Resulting data without inactive elements.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_active_zero_padded</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">])):</span>
                <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_active_padded_first_dim</span><span class="p">(</span><span class="n">out_data</span><span class="p">,</span> <span class="n">out_num_active</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">in_mask</span><span class="p">):</span>
        <span class="n">active_mask</span> <span class="o">=</span> <span class="n">in_mask</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">res_active</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">[</span><span class="n">active_mask</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">out_data</span><span class="p">[:</span> <span class="n">res_active</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_active</span>
        <span class="n">out_num_active</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">res_active</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">num_dims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;num_dims must be greater than 0&quot;</span>

    <span class="c1"># Make permutation to switch between the first and the masked dimension. Works both for the forward and backward step</span>
    <span class="n">switch_first_dim_permutation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_dims</span><span class="p">))</span>
    <span class="n">switch_first_dim_permutation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">masked_dimension</span>
    <span class="n">switch_first_dim_permutation</span><span class="p">[</span><span class="n">masked_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># @TODO: use BOOL directly?</span>

    <span class="n">data_permutated</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">switch_first_dim_permutation</span><span class="p">)</span>
    <span class="n">res_permutated_padded</span><span class="p">,</span> <span class="n">num_active_elements_as_arr</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">data_permutated</span><span class="p">,</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">active_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">),</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_active_padded_first_dim</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_active_zero_padded</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">res_permutated</span> <span class="o">=</span> <span class="n">res_permutated_padded</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">num_active_elements_as_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">res_permutated</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">switch_first_dim_permutation</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="ensure_range">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.ensure_range">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_range</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Ensure that the data (containing values from a periodic range) is in a given range (which may be</span>
<span class="sd">    larger than one period).</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        data: Data to process.</span>
<span class="sd">        min_value: Minimum border of the range to bring values into.</span>
<span class="sd">        max_value: Maximum border of the range to bring values into.</span>
<span class="sd">        period: Period of the data values one or multiple periods are added or subtracted from the values to</span>
<span class="sd">            bring them into the desired range.</span>
<span class="sd">        num_dims: Number of dimensions in the data. For scalar data, set to ``0``.</span>
<span class="sd">        data_type: Data type of ``data``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Resulting data where the elements are in the range.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_ensure_range</span><span class="p">(</span><span class="n">out_data</span><span class="p">,</span> <span class="n">in_data</span><span class="p">):</span>
        <span class="n">out_data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">[:]</span>
        <span class="n">too_low_mask</span> <span class="o">=</span> <span class="n">out_data</span> <span class="o">&lt;</span> <span class="n">min_value</span>
        <span class="n">too_high_mask</span> <span class="o">=</span> <span class="n">out_data</span> <span class="o">&gt;</span> <span class="n">max_value</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">too_low_mask</span><span class="p">):</span>
            <span class="n">to_change</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">[</span><span class="n">too_low_mask</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">min_value</span> <span class="o">-</span> <span class="n">to_change</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span> <span class="o">/</span> <span class="n">period</span><span class="p">)</span> <span class="o">*</span> <span class="n">period</span>
            <span class="n">out_data</span><span class="p">[</span><span class="n">too_low_mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">to_add</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">too_high_mask</span><span class="p">):</span>
            <span class="n">to_change</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">[</span><span class="n">too_high_mask</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">to_change</span> <span class="o">-</span> <span class="n">max_value</span>
            <span class="n">to_subtract</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span> <span class="o">/</span> <span class="n">period</span><span class="p">)</span> <span class="o">*</span> <span class="n">period</span>
            <span class="n">out_data</span><span class="p">[</span><span class="n">too_high_mask</span><span class="p">]</span> <span class="o">-=</span> <span class="n">to_subtract</span>

    <span class="c1"># cannot import 0D arrays to the numba OP; wrap scalars to 1D for the OP and squeeze back afterwards</span>
    <span class="n">data_for_op</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">op_num_dims</span> <span class="o">=</span> <span class="n">num_dims</span>
    <span class="k">if</span> <span class="n">num_dims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data_for_op</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">op_num_dims</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">data_for_op</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">run_ensure_range</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">op_num_dims</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">op_num_dims</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">num_dims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="replace_nans">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.replace_nans">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_nans</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">replacement_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Replace ``nan`` values in data.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        data: Data to apply to.</span>
<span class="sd">        replacement_value: Value to replace ``nan`` values with.</span>
<span class="sd">        num_dims: Number of dimensions in the data.</span>
<span class="sd">        data_type: Data type of ``data``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Data with ``nans`` replaced by ``replacement_value``.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_replace_nans</span><span class="p">(</span><span class="n">out_data</span><span class="p">,</span> <span class="n">in_data</span><span class="p">):</span>

        <span class="n">out_data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">[:]</span>

        <span class="n">flat_data</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">flat_data</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">flat_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement_value</span>

        <span class="n">out_data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">flat_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[:]</span>

    <span class="k">assert</span> <span class="n">num_dims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;num_dims must be greater than 0&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">run_replace_nans</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="n">num_dims</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="check_bbox_visibiity">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.check_bbox_visibiity">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">check_bbox_visibiity</span><span class="p">(</span>
    <span class="n">bboxes</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">depths</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">shrink_bbox_to_obtain_int_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Check visibility of bounding boxes.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    A bounding box is considered visible if it is not completely occluded by other bounding boxes with</span>
<span class="sd">    smaller depth (i.e. fully covered by other boxes).</span>

<span class="sd">    Args:</span>
<span class="sd">        bboxes: Bounding boxes to process. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`. Expected to be a matrix with each row containing</span>
<span class="sd">            one bounding box, i.e. first the upper left and then the lower right corner in the format</span>
<span class="sd">            ``[x1, y1, x2, y2]``.</span>
<span class="sd">        depths: Depths of the individual bounding boxes. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        image_hw: The height and width of the image in which the bounding boxes are used. Data elements are</span>
<span class="sd">            expected to be of type :class:`nvidia.dali.types.DALIDataType.INT32`.</span>
<span class="sd">        shrink_bbox_to_obtain_int_coords: Whether to shrink the bounding box to obtain integer coordinates.</span>
<span class="sd">            If ``True``, the bounding box is shrunk to the nearest integer coordinates. If ``False``, the bounding box</span>
<span class="sd">            is expanded instead.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean mask indicating for each bounding box whether it is visible.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_check</span><span class="p">(</span><span class="n">out_mask</span><span class="p">,</span> <span class="n">in_bboxes</span><span class="p">,</span> <span class="n">in_depths</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">):</span>

        <span class="c1"># Note that in_image_hw cannot be passed directly when using Numba, and instead the correct argument type needs to be used</span>
        <span class="n">canvas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">in_image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">depth_ordered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">in_depths</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">doi</span> <span class="ow">in</span> <span class="n">depth_ordered_indices</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">in_bboxes</span><span class="p">[</span><span class="n">doi</span><span class="p">]</span>
            <span class="c1"># The bounding box may have been reflected (e.g. due to scaling with negative scaling factor). Therefore, first extract</span>
            <span class="c1"># the minimum and maximum values for both x and y instead of assuming that the first point is the upper left corner.</span>
            <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get the minimum and maximum points as int values</span>
            <span class="k">if</span> <span class="n">shrink_bbox_to_obtain_int_coords</span><span class="p">:</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_x</span><span class="p">))</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_y</span><span class="p">))</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_x</span><span class="p">))</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_y</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_x</span><span class="p">))</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_y</span><span class="p">))</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_x</span><span class="p">))</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_y</span><span class="p">))</span>

            <span class="c1"># Check if the bounding box is completely outside the image</span>
            <span class="k">if</span> <span class="n">min_x</span> <span class="o">&gt;</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">max_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_y</span> <span class="o">&gt;</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">max_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Clip the bounding box to the image</span>
            <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">min_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_y</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Draw rect with index of current bounding box</span>
            <span class="n">canvas</span><span class="p">[</span><span class="n">min_y</span><span class="p">:</span><span class="n">max_y</span><span class="p">,</span> <span class="n">min_x</span><span class="p">:</span><span class="n">max_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">doi</span>

        <span class="c1"># See which indices are still visible (and remove the background of -1)</span>
        <span class="n">unique_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">canvas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">unique_sorted</span> <span class="o">=</span> <span class="n">unique_sorted</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Set mask of the visible bboxes to 1 (True)</span>
        <span class="n">out_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">out_mask</span><span class="p">[</span><span class="n">unique_sorted</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">bboxes</span><span class="p">,</span>
        <span class="n">depths</span><span class="p">,</span>
        <span class="n">image_hw</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">perform_check</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">BOOL</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="check_minimum_bbox_size">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.check_minimum_bbox_size">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">check_minimum_bbox_size</span><span class="p">(</span><span class="n">bboxes</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">min_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Check whether a bounding box has a minimum size in both dimensions.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    The bounding box is clipped to the image size before the check is performed.</span>

<span class="sd">    Args:</span>
<span class="sd">        bboxes: Bounding boxes to process. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`. Expected to be a matrix with each row containing</span>
<span class="sd">            one bounding box, i.e. first the upper left and then the lower right corner.</span>
<span class="sd">        min_size: Minimum size of the bounding box in both dimensions (height, width).</span>
<span class="sd">        image_hw: The height and width of the image in which the bounding boxes are used. Data elements are</span>
<span class="sd">            expected to be of type :class:`nvidia.dali.types.DALIDataType.INT32`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean mask indicating for each bounding box whether it has a minimum size in both dimensions.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_check</span><span class="p">(</span><span class="n">out_mask</span><span class="p">,</span> <span class="n">in_bboxes</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">):</span>
        <span class="c1"># Copy bboxes input as it is not allowed to change the inputs and we need to adjust them</span>
        <span class="c1"># bboxes_adjusted = np.zeros_like(in_bboxes)</span>
        <span class="n">bboxes_adjusted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">in_bboxes</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">bboxes_adjusted</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">in_bboxes</span><span class="p">[:]</span>
        <span class="c1"># Clip x-coords</span>
        <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Clip y-coords</span>
        <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">in_image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># GEt bbox size in both dimensions</span>
        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bboxes_adjusted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Chec whether bbox has at least minimum size in both dimensions</span>
        <span class="n">out_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">diff_x</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">diff_y</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">bboxes</span><span class="p">,</span>
        <span class="n">image_hw</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">perform_check</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">BOOL</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="check_points_in_box">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.check_points_in_box">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">check_points_in_box</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">min_point</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_point</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Check whether points are inside an axis-aligned box.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        points: Points to check. Each row corresponds to one point. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        min_point: Minimum corner (in all dimensions) of the box.</span>
<span class="sd">        max_point: Maximum corner (in all dimensions) of the box.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean mask indicating which points are inside the box.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Will be accessed in perform_check. Note that the convertion to numpy arrays needs to happen here as otherwise it leads to errors.</span>
    <span class="c1"># Performing the conversion here is also more efficient as it will happen once at grapgh construction time and treated inside the</span>
    <span class="c1"># perform_check as constants.</span>
    <span class="n">min_point_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">min_point</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_point_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">max_point</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_check</span><span class="p">(</span><span class="n">out_mask</span><span class="p">,</span> <span class="n">in_points</span><span class="p">):</span>
        <span class="n">element_wise_above_min</span> <span class="o">=</span> <span class="n">in_points</span> <span class="o">&gt;=</span> <span class="n">min_point_np</span>
        <span class="n">element_wise_below_max</span> <span class="o">=</span> <span class="n">in_points</span> <span class="o">&lt;=</span> <span class="n">max_point_np</span>
        <span class="n">element_wise_inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">element_wise_above_min</span><span class="p">,</span> <span class="n">element_wise_below_max</span><span class="p">)</span>

        <span class="c1"># workaround due to `axis` argument for `np.min` not working with numba</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">element_wise_inside</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">out_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">element_wise_inside</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">perform_check</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">BOOL</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="crop_coordinates">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.crop_coordinates">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">crop_coordinates</span><span class="p">(</span>
    <span class="n">points</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">min_point_np</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_point_np</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Crop coordinates to a given range.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        points: Points to check. Each row corresponds to one point. Data type is expected to be</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">            Note that the point may have any number of dimensions (i.e. any number of columns in the input data).</span>
<span class="sd">            This can e.g. be used to express bounding boxes as points, where two diagonally opposite points</span>
<span class="sd">            are given for each entry, and the two points are combined as ``[min_x, min_y, max_x, max_y]``.</span>
<span class="sd">        min_point: Minimum corner (in all dimensions) of the box.</span>
<span class="sd">        max_point: Maximum corner (in all dimensions) of the box.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Points with coordinates cropped to the given range.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># Copy input shape to output shape properly</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)):</span>
                <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="n">dim_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="n">dim_idx</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_cropping</span><span class="p">(</span><span class="n">out_points</span><span class="p">,</span> <span class="n">in_points</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">in_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">min_val</span> <span class="o">=</span> <span class="n">min_point_np</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">max_val</span> <span class="o">=</span> <span class="n">max_point_np</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">out_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_val</span>
                <span class="k">elif</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">max_val</span><span class="p">:</span>
                    <span class="n">out_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">perform_cropping</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">dtype</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">dtype</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_rot_mat_from_rot_vector">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.get_rot_mat_from_rot_vector">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_rot_mat_from_rot_vector</span><span class="p">(</span><span class="n">rot_vector</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">as_homog</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Get a rotation matrix from a Rodrigues rotation vector.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        rot_vector: Rodrigues rotation vector. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        as_homog: Whether to return a homogeneous transformation matrix.</span>
<span class="sd">        eps: Small value to avoid division by zero. Vectors with length below</span>
<span class="sd">            this value are considered to be zero.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Rotation matrix. If ``as_homog`` is ``True``, the matrix is a homogeneous transformation matrix.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Compted at graph construction time and can be used as a constant inside get_matrix()</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">as_homog</span> <span class="k">else</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_matrix</span><span class="p">(</span><span class="n">out_matrix</span><span class="p">,</span> <span class="n">in_vector</span><span class="p">):</span>

        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">in_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">identity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">in_vector</span> <span class="o">/</span> <span class="n">angle</span>

            <span class="n">cross_mat</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">]]</span>
            <span class="n">cross_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cross_mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">sin_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

            <span class="n">rot_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">identity</span> <span class="o">+</span> <span class="n">sin_angle</span> <span class="o">*</span> <span class="n">cross_mat</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_angle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cross_mat</span> <span class="o">@</span> <span class="n">cross_mat</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_homog</span><span class="p">:</span>
            <span class="n">out_matrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">rot_mat</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot_mat</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">rot_vector</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_translation_mat_from_vector">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.get_translation_mat_from_vector">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_translation_mat_from_vector</span><span class="p">(</span><span class="n">translation</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Get a translation matrix from a translation vector.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        translation: Translation vector. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Translation matrix (homogeneous transformation matrix).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_matrix</span><span class="p">(</span><span class="n">out_matrix</span><span class="p">,</span> <span class="n">in_vector</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_vector</span>
        <span class="n">out_matrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">translation</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_scaling_mat_from_vector">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.get_scaling_mat_from_vector">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_scaling_mat_from_vector</span><span class="p">(</span><span class="n">scaling</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">as_homog</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Get a scaling matrix from a scaling vector.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        scaling: Vector containing the scaling factors for each dimension. Data elements are expected to be</span>
<span class="sd">            of type :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        as_homog: Whether to return a homogeneous transformation matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scaling matrix. If ``as_homog`` is ``True``, the matrix is a homogeneous transformation matrix.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">as_homog</span> <span class="k">else</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_matrix</span><span class="p">(</span><span class="n">out_matrix</span><span class="p">,</span> <span class="n">in_vector</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_homog</span><span class="p">:</span>
            <span class="n">out_matrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">out_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">scaling</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<span class="c1"># Inner function as needed in `apply_matrix()`. This is because `@do_not_convert` cannot be used for `apply_matrix()`</span>
<span class="c1"># due to if-conditions based on DataNode data (i.e. conditions need to be evaluated at graph execution time,</span>
<span class="c1"># not construction time).</span>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_apply_matrix_2d_input_ensured</span><span class="p">(</span>
    <span class="n">to_apply_to</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">in_homog</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">to_apply_to_is_transposed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">matrix_is_transposed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">matrix_is_inverted</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">multiply_matrix_from_right</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][:]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">do_apply_matrix</span><span class="p">(</span><span class="n">out_applied</span><span class="p">,</span> <span class="n">in_to_apply_to</span><span class="p">,</span> <span class="n">in_matrix</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">in_to_apply_to</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">in_to_apply_to</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="n">to_apply_to_is_transposed</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">in_homog</span><span class="p">:</span>
            <span class="n">ones_to_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">ones_to_add</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">matrix_is_transposed</span><span class="p">:</span>
            <span class="n">matrix_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">in_matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix_to_use</span> <span class="o">=</span> <span class="n">in_matrix</span>

        <span class="k">if</span> <span class="n">matrix_is_inverted</span><span class="p">:</span>
            <span class="n">temp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">matrix_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">temp_mat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">matrix_to_use</span><span class="p">[:]</span>
            <span class="n">matrix_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">temp_mat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiply_matrix_from_right</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">matrix_to_use</span> <span class="o">@</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">@</span> <span class="n">matrix_to_use</span>

        <span class="k">if</span> <span class="n">in_homog</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">to_apply_to_is_transposed</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">out_applied</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">to_apply_to</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">do_apply_matrix</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="c1"># Note that this function uses `_apply_matrix_2d_input_ensured()` as the actual operator implementation. This is to avoid using `@do_not_convert`</span>
<span class="c1"># on this function, thereby anabling the use of (pipeline run time) conditionals inside it.</span>
<div class="viewcode-block" id="apply_matrix">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.apply_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_matrix</span><span class="p">(</span>
    <span class="n">to_apply_to</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">make_apply_to_homog</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">to_apply_to_is_transposed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">matrix_is_transposed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">matrix_is_inverted</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">multiply_matrix_from_right</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Apply a matrix to data (vector or matrix).</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        to_apply_to: Data node to apply the matrix to. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        matrix: Matrix to apply. Data elements are expected to be of type</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">        make_apply_to_homog: Whether to make the input homogeneous before applying the matrix.</span>
<span class="sd">            The result will be converted back to Euclidean space after applying the matrix.</span>
<span class="sd">        to_apply_to_is_transposed: Whether the input is transposed.</span>
<span class="sd">            If set, the input will be transposed before applying the matrix, and transposed back afterwards.</span>
<span class="sd">        matrix_is_transposed: Whether the matrix is transposed.</span>
<span class="sd">            If set, the matrix will be transposed before applying it.</span>
<span class="sd">        matrix_is_inverted: Whether the matrix is inverted.</span>
<span class="sd">            If set, the matrix will be inverted before applying it.</span>
<span class="sd">        multiply_matrix_from_right: Whether to multiply the matrix from the right.</span>
<span class="sd">            If set, the matrix will be multiplied from the right (otherwise from the left).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Data with the matrix applied.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># If the input is 1D, the shape of the shape is 1</span>
    <span class="n">is_to_apply_to_1d</span> <span class="o">=</span> <span class="n">to_apply_to</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">is_to_apply_to_1d</span><span class="p">:</span>
        <span class="n">to_apply_to</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">to_apply_to</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_apply_matrix_2d_input_ensured</span><span class="p">(</span>
        <span class="n">to_apply_to</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">,</span>
        <span class="n">make_apply_to_homog</span><span class="p">,</span>
        <span class="n">to_apply_to_is_transposed</span><span class="p">,</span>
        <span class="n">matrix_is_transposed</span><span class="p">,</span>
        <span class="n">matrix_is_inverted</span><span class="p">,</span>
        <span class="n">multiply_matrix_from_right</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">is_to_apply_to_1d</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_center_from_bboxes">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.get_center_from_bboxes">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_center_from_bboxes</span><span class="p">(</span>
    <span class="n">bboxes</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span> <span class="n">dtype_in</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Get the center of bounding boxes.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    Args:</span>
<span class="sd">        bboxes: Bounding boxes. The first dimension (``dim==0``) iterates over the bounding boxes.</span>
<span class="sd">            Each bounding box is expected to be in the format ``[x1, y1, x2, y2]``, where ``(x1, y1)`` and</span>
<span class="sd">            ``(x2, y2)`` are the coordinates of the two diagonally opposite corners of the bounding box.</span>
<span class="sd">        dtype_in: Data type of the bounding boxes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The center of the bounding boxes. The data type of the output is</span>
<span class="sd">        :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_center</span><span class="p">(</span><span class="n">out_center</span><span class="p">,</span> <span class="n">in_bboxes</span><span class="p">):</span>
        <span class="n">in_bboxes</span> <span class="o">=</span> <span class="n">in_bboxes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_bboxes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">out_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_bboxes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_bboxes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="n">out_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_bboxes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_bboxes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">bboxes</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_center</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">dtype_in</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_radii_from_bboxes">
<a class="viewcode-back" href="../../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/operators_impl.html#accvlab.dali_pipeline_framework.operators_impl.numba_operators.get_radii_from_bboxes">[docs]</a>
<span class="nd">@do_not_convert</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_radii_from_bboxes</span><span class="p">(</span>
    <span class="n">bboxes</span><span class="p">:</span> <span class="n">DataNode</span><span class="p">,</span>
    <span class="n">dtype_bboxes</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
    <span class="n">scaling_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">centers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataNode</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype_center</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Compute radii from bounding boxes and a scaling factor.</span>

<span class="sd">    :cpu:</span>

<span class="sd">    The radius is the minimum distance from the bounding box center to its border scaled by the scaling</span>
<span class="sd">    factor. The center to use can be provided as an input (may not correspond to the geometrical center of</span>
<span class="sd">    the bounding box), or computed from the bounding boxes.</span>

<span class="sd">    Note:</span>
<span class="sd">        The bounding boxes are expected to be in the format ``[x1, y1, x2, y2]``, where ``(x1, y1)`` and</span>
<span class="sd">        ``(x2, y2)`` are the coordinates of the two diagonally opposite corners of the bounding box. No</span>
<span class="sd">        assumption is made on the order of the points or on which diagonal the points are on.</span>

<span class="sd">    Args:</span>
<span class="sd">        bboxes: Bounding boxes.</span>
<span class="sd">        dtype_bboxes: Data type of the bounding boxes.</span>
<span class="sd">        scaling_factor: Scaling factor for the radii.</span>
<span class="sd">        centers: Centers of the bounding boxes.</span>
<span class="sd">        dtype_center: Data type of the center.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Radii. The data type of the output is :class:`nvidia.dali.types.DALIDataType.FLOAT`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setup_result_size</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_radii</span><span class="p">(</span><span class="n">out_radii</span><span class="p">,</span> <span class="n">in_bboxes</span><span class="p">,</span> <span class="n">in_center</span><span class="p">):</span>
        <span class="n">in_bboxes</span> <span class="o">=</span> <span class="n">in_bboxes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">in_center</span> <span class="o">=</span> <span class="n">in_center</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># Note that the bboxes are in the format [x1, y1, x2, y2]</span>
        <span class="c1"># and the two points are on the opposite corners of a diagonal of the box.</span>
        <span class="c1"># However, they could be on either of the diagonals, and in any order.</span>
        <span class="c1"># Therefore, we need to find the top, left, bottom, and right coordinates of the box.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_bboxes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">in_center_i</span> <span class="o">=</span> <span class="n">in_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">in_bbox_i</span> <span class="o">=</span> <span class="n">in_bboxes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">bbox_l</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bbox_r</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bbox_l</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">bbox_r</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">bbox_t</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">bbox_b</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bbox_t</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">bbox_b</span> <span class="o">=</span> <span class="n">in_bbox_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Distance to left</span>
            <span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_center_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox_l</span>
            <span class="c1"># Distance to top</span>
            <span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_center_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox_t</span>
            <span class="c1"># Distance to right</span>
            <span class="n">dists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox_r</span> <span class="o">-</span> <span class="n">in_center_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Distance to right</span>
            <span class="n">dists</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox_b</span> <span class="o">-</span> <span class="n">in_center_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># The distance is the minimum of the distances to the edges of the bounding box.</span>
            <span class="c1"># If the distance is negative, it means that the center is outside the bounding box, and the</span>
            <span class="c1"># radius is 0.</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">scaling_factor</span>
            <span class="n">out_radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="k">if</span> <span class="n">centers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">get_center_from_bboxes</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">dtype_in</span><span class="o">=</span><span class="n">dtype_bboxes</span><span class="p">)</span>
        <span class="n">dtype_center</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fnex</span><span class="o">.</span><span class="n">numba_function</span><span class="p">(</span>
        <span class="n">bboxes</span><span class="p">,</span>
        <span class="n">centers</span><span class="p">,</span>
        <span class="n">setup_fn</span><span class="o">=</span><span class="n">setup_result_size</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="o">=</span><span class="n">get_radii</span><span class="p">,</span>
        <span class="n">in_types</span><span class="o">=</span><span class="p">[</span><span class="n">dtype_bboxes</span><span class="p">,</span> <span class="n">dtype_center</span><span class="p">],</span>
        <span class="n">out_types</span><span class="o">=</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">],</span>
        <span class="n">ins_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">outs_ndim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, NVIDIA Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>