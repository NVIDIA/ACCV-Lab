

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>accvlab.dali_pipeline_framework.pipeline.sample_data_group &mdash; ACCV-Lab 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=9282052d" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ACCV-Lab
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">General Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../project_overview/README.html">ACCV-Lab Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides_index.html">Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contained Packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/on_demand_video_decoder/docs/index.html">On Demand Video Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/batching_helpers/docs/index.html">Batching Helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/index.html">DALI Pipeline Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/draw_heatmap/docs/index.html">Draw Heatmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/optim_test_tools/docs/index.html">Optimization Testing Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ACCV-Lab</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">accvlab.dali_pipeline_framework.pipeline.sample_data_group</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for accvlab.dali_pipeline_framework.pipeline.sample_data_group</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2025, NVIDIA CORPORATION &amp; AFFILIATES. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># Used to enable type hints using a class type inside the implementation of that class itself.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dali</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.fn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.types</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">types</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..internal_helpers</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_type</span><span class="p">,</span> <span class="n">get_mapped</span>


<div class="viewcode-block" id="SampleDataGroup">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SampleDataGroup</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Structured container for sample data. Can also be used as a blueprint to describe the data format.</span>

<span class="sd">    Data is organized as a tree containing:</span>

<span class="sd">      - **Data fields**: Leaf nodes that hold the actual data.</span>
<span class="sd">      - **Data group fields**: Non-leaf nodes that group related items.</span>

<span class="sd">    Example:</span>

<span class="sd">        An example for accessing the data field ``&quot;bounding_boxes&quot;`` inside nested data group fields</span>
<span class="sd">        ``&quot;camera&quot;`` and ``&quot;annotations&quot;``:</span>

<span class="sd">        &gt;&gt;&gt; bounding_boxes = data[&quot;camera&quot;][&quot;annotations&quot;][&quot;bounding_boxes&quot;]</span>

<span class="sd">        Note that accessing the data is done as for a nested dictionary. Here, the data group fields are</span>
<span class="sd">        analogous to :class:`dict` objects and data fields correspond to the actual stored values at</span>
<span class="sd">        the leaves.</span>

<span class="sd">    Capabilities (see individual method docs for details):</span>

<span class="sd">      - Enforce a predefined data format (field names, order, and types). Format changes need to be performed</span>
<span class="sd">        explicitly.</span>
<span class="sd">      - Inside the input callable/iterable and outside the DALI pipeline the following can be performed (both</span>
<span class="sd">        can be disabled):</span>

<span class="sd">        - Apply automatic type conversions (e.g., integers to floats) on assignment</span>
<span class="sd">        - Apply optional custom string-to-numeric mappings on assignment for selected fields (see</span>
<span class="sd">          :meth:`add_data_field`, :meth:`add_data_field_array`, and :meth:`set_apply_mapping`).</span>
<span class="sd">      - Inside the pipeline: Apply automatic type checks on assignment.</span>
<span class="sd">      - Render the tree in a human-readable form via ``print(obj)``.</span>
<span class="sd">      - Flatten values to a sequence and reconstruct from a sequence (see :meth:`get_data`, :meth:`set_data`,</span>
<span class="sd">        and :meth:`set_data_from_dali_generic_iterator_output`).</span>
<span class="sd">        This is useful when passing the data from the input callable/iterable to the pipeline, and when</span>
<span class="sd">        returning data from the pipeline, as nested data structures are not supported there. Also</span>
<span class="sd">        see :class:`DALIStructuredOutputIterator` for an output iterator which re-assembles the data from</span>
<span class="sd">        the flattened output into a :class:`SampleDataGroup` instance or nested dictionaries before returning</span>
<span class="sd">        it.</span>
<span class="sd">      - Compare formats of two instances (see :meth:`type_matches`). This also ensures that the flattened</span>
<span class="sd">        data obtained from one instance can be used to fill the data of another instance.</span>
<span class="sd">      - Utilities that facilitate implementation of pipeline steps: find/remove all occurrences of fields</span>
<span class="sd">        with a given name, add/remove/change fields and types, etc. (e.g. see</span>
<span class="sd">        :meth:`find_all_occurrences`). Note that the search is performed at DALI graph construction time, so</span>
<span class="sd">        there is no overhead during the pipeline execution.</span>
<span class="sd">      - Supports passing strings through the DALI pipeline and obtaining them as strings in the pipeline</span>
<span class="sd">        output. Note that strings are not supported inside the DALI pipeline. They can be accessed/assigned</span>
<span class="sd">        as strings in the input callable/iterable and outside the DALI pipeline, but appear as uint8 tensors</span>
<span class="sd">        inside the pipeline itself (alternative: use a mapping to numeric values as described above).</span>

<span class="sd">    Usage modes:</span>

<span class="sd">      - **Blueprint**: describes the data format (fields and types) but contains no values. This allows</span>
<span class="sd">        inferring downstream formats without running data processing (e.g., to initialize a DALI iterator).</span>
<span class="sd">        When only passing of flattened data is possible, a blueprint can be filled from flattened values</span>
<span class="sd">        (see :meth:`get_data`, :meth:`set_data`).</span>
<span class="sd">      - **Container**: holds actual values. When accessing the data, behaves similarly to a nested dictionary.</span>
<span class="sd">        When assigning data, additional checks/conversions are potentially performed.</span>


<span class="sd">    Important:</span>
<span class="sd">        **Assigning a Field Value**</span>

<span class="sd">        Assignment means using the indexed assignment operator ``obj[name] = value`` or the</span>
<span class="sd">        method ``obj.set_item_in_path(path, value)``.</span>

<span class="sd">        When assigning data fields, the following holds:</span>

<span class="sd">          - Mappings and conversions will be performed on assignment (inside the input callable/iterable</span>
<span class="sd">            and outside the DALI pipeline; if not disabled). Inside the DALI pipeline itself, no mapping</span>
<span class="sd">            or conversion is applied.</span>
<span class="sd">          - Inside the DALI pipeline, type checks are performed instead on assignment and an error is</span>
<span class="sd">            raised if the type is not correct.</span>
<span class="sd">          - Assigning strings is only supported in the input callable/iterable and outside the DALI</span>
<span class="sd">            pipeline. String fields are handled as uint8 tensors inside the DALI pipeline.</span>

<span class="sd">        When assigning to data group fields, the following holds:</span>

<span class="sd">          - The assignment succeeds only if the new value&#39;s format matches the previous format,</span>
<span class="sd">            i.e. if ``obj[name].type_matches(value)`` holds. Otherwise, a :class:`KeyError` is raised.</span>
<span class="sd">            This is done to prevent changing the data format implicitly by assigning a different type.</span>
<span class="sd">          - If the type needs to be changed, this needs to be done explicitly first (e.g., using</span>
<span class="sd">            :meth:`change_type_of_data_and_remove_data`).</span>

<span class="sd">    Important:</span>
<span class="sd">        **Getting a Field Value**</span>

<span class="sd">        Getting a field value means using the indexed access operator ``obj[name]`` or the method</span>
<span class="sd">        ``obj.get_item_in_path(path)``.</span>

<span class="sd">        Accessing strings inside the DALI pipeline (except for the input callable/iterable) will return</span>
<span class="sd">        the underlying uint8 tensor instead. Using strings directly is only supported in the input</span>
<span class="sd">        callable/iterable and outside the DALI pipeline.</span>

<span class="sd">    Important:</span>
<span class="sd">        **Changing the Data Format**</span>

<span class="sd">        Changing the data format is always explicit. For example, adding a field and assigning values is a</span>
<span class="sd">        two-step process: create the field first, then assign data. When defining a blueprint, fields are</span>
<span class="sd">        created but left empty.</span>

<span class="sd">    Important:</span>
<span class="sd">        **Type Checking**</span>

<span class="sd">        Type checking is performed on assignment to ensure that the data type is correct (inside the DALI</span>
<span class="sd">        pipeline). This is useful when developing the pipeline/processing step, but adds some overhead. Type</span>
<span class="sd">        checking is enabled by default (see :meth:`set_do_check_type`).</span>

<span class="sd">    Note:</span>
<span class="sd">        Additional information:</span>

<span class="sd">           - When converting a :class:`SampleDataGroup` to a string (e.g., using ``print(obj)``), the data format</span>
<span class="sd">             as well as some details (e.g., for which fields a mapping is defined, which fields are empty,</span>
<span class="sd">             data types of the fields) are printed. The actual stored values are not printed.</span>
<span class="sd">             For a more simple output, see :meth:`get_string_no_details`.</span>
<span class="sd">           - When obtaining the length of a :class:`SampleDataGroup` (e.g., using ``len(obj)``), the number of</span>
<span class="sd">             direct children (data fields and data group fields) is returned.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">_type_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">BOOL</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
        <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">)):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_apply_mapping</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_convert</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_check_type</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="SampleDataGroup.create_data_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.create_data_field_array">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_data_field_array</span><span class="p">(</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span>
        <span class="n">num_fields</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Create a :class:`SampleDataGroup` containing multiple data fields of the same type.</span>

<span class="sd">        The data fields have numerical (integer) names in the range ``[0; num_fields - 1]``. This means that</span>
<span class="sd">        the returned :class:`SampleDataGroup` behaves as an array of data fields.</span>

<span class="sd">        Args:</span>
<span class="sd">            type: Type of the fields to add</span>
<span class="sd">            num_fields: Number of fields to add to the array data group field</span>
<span class="sd">            mapping: Optional mapping for the fields (see :meth:`add_data_field` for details on mappings).</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`create_data_group_field_array`</span>
<span class="sd">            :meth:`add_data_field_array`</span>
<span class="sd">            :meth:`add_data_group_field_array`</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting array :class:`SampleDataGroup` object</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">SampleDataGroup</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_fields</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add_data_field</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.create_data_group_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.create_data_group_field_array">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_data_group_field_array</span><span class="p">(</span><span class="n">sample_data_group</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">,</span> <span class="n">num_fields</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Create a :class:`SampleDataGroup` containing multiple data group fields (themselves :class:`SampleDataGroup` instances).</span>

<span class="sd">        Note that the created data group fields will be initialized as blueprints, i.e. they will not contain</span>
<span class="sd">        any actual data even if ``sample_data_group`` does. This is done to cleanly separate</span>
<span class="sd">        this step (defining the data format) from actually filling the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            sample_data_group: Blueprint representing the element format. Any actual data present in</span>
<span class="sd">                ``sample_data_group`` will be ignored; the resulting elements will be empty of data.</span>
<span class="sd">            num_fields: Number of fields to create</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`create_data_field_array`</span>
<span class="sd">            :meth:`add_data_field_array`</span>
<span class="sd">            :meth:`add_data_group_field_array`</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting array :class:`SampleDataGroup` object</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">SampleDataGroup</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_fields</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add_data_group_field</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sample_data_group</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.set_apply_mapping">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_apply_mapping">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_apply_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set whether to apply string to numeric mapping (for data fields where such a mapping is defined).</span>

<span class="sd">        This setting will be propagated to descendants (data group fields) of the data group field for which</span>
<span class="sd">        it is called.</span>

<span class="sd">        Note:</span>
<span class="sd">            The mapping is applied in the input callable/iterable and outside the DALI pipeline.</span>
<span class="sd">            Inside the DALI pipeline itself, the mapping is not applied. If apply mapping is set to ``True``</span>
<span class="sd">            and an assignment is performed inside the pipeline, a warning will be issued, and the assignment</span>
<span class="sd">            will be performed without mapping (if it is already in the correct format; an error will be</span>
<span class="sd">            raised if the format is not correct).</span>

<span class="sd">        Args:</span>
<span class="sd">            apply: Whether to apply the mapping (for fields where a mapping is set).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_apply_mapping</span> <span class="o">=</span> <span class="n">apply</span>
        <span class="c1"># Also set (recursively) in SampleDataGroup elements</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_apply_mapping</span><span class="p">(</span><span class="n">apply</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.set_do_convert">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_do_convert">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_do_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convert</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set whether to convert data in the data fields to the types set up when creating those fields.</span>

<span class="sd">        This setting will be propagated to descendants (data group fields) of the data group field for which</span>
<span class="sd">        it is called.</span>

<span class="sd">        Note:</span>
<span class="sd">            The conversion is applied in the input callable/iterable and outside the DALI pipeline.</span>
<span class="sd">            Inside the DALI pipeline itself, the conversion is not applied. Instead, type checks are performed</span>
<span class="sd">            (regardless of this setting).</span>

<span class="sd">        Args:</span>
<span class="sd">            convert: Whether to perform automatic type conversions (e.g., integers to floats) on assignment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_convert</span> <span class="o">=</span> <span class="n">convert</span>
        <span class="c1"># Also set (recursively) in SampleDataGroup elements</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_do_convert</span><span class="p">(</span><span class="n">convert</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.set_do_check_type">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_do_check_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_do_check_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check_type</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set whether to perform type checking on assignment.</span>

<span class="sd">        This setting will be propagated to descendants (data group fields) of the data group field for which</span>
<span class="sd">        it is called.</span>

<span class="sd">        Note:</span>
<span class="sd">            The type checking is useful when developing the pipeline/processing step, but adds some overhead.</span>
<span class="sd">            Therefore, it is advisable to disable it in production.</span>

<span class="sd">        Args:</span>
<span class="sd">            check_type: Whether to perform type checking (in the DALI pipeline) on assignment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_check_type</span> <span class="o">=</span> <span class="n">check_type</span>
        <span class="c1"># Also set (recursively) in SampleDataGroup elements</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_do_check_type</span><span class="p">(</span><span class="n">check_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_empty_like_self">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_empty_like_self">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_empty_like_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get an object with the same structure (same nested data group fields and data fields), but no values.</span>

<span class="sd">        Obtain a blueprint either from another blueprint or from a populated object (ignoring values and</span>
<span class="sd">        initializing all data fields as empty). This can be regarded as a deep-copy of the original object,</span>
<span class="sd">        but with the actual data removed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting blueprint :class:`SampleDataGroup` object.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_copy_except_values</span><span class="p">()</span>
        <span class="c1"># Values should be empty (except which are SampleDataGroups themselves, see next step), but the</span>
        <span class="c1"># correct fields should be set up and filled with &#39;None&#39;</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="c1"># If the element is itself a SampleDataGroup, ensure we get the correct empty like the element</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get_empty_like_self</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the element is a primitive, set it to None</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_copy">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get a copy.</span>

<span class="sd">        Create a copy: equivalent to :meth:`get_empty_like_self` followed by filling the data from the</span>
<span class="sd">        original object. Note that for the actual data, references to the original data are used, i.e. the</span>
<span class="sd">        data itself is not deep-copied. However, the data group fields making up the data format are</span>
<span class="sd">        deep-copied.</span>

<span class="sd">        This means that modifying the data in place will modify the data in the original. However, assigning</span>
<span class="sd">        new data to fields, adding or deleting fields, changing their type etc. will not affect the original.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting copy</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_copy_except_values</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Values should be re-used. However, the individual values should be not deep-copied.</span>
        <span class="c1"># Instead, build a new dictionary (so that adding or removing keys will not affect the original),</span>
        <span class="c1"># but use references to the original objects for the actual values except for SampleDataGroup</span>
        <span class="c1"># elements, which are handled differently (see below)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="c1"># If the element is itself a SampleDataGroup, ensure it is copied correctly by calling</span>
                <span class="c1"># get_copy recursively.</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get_copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the element is not a SampleDataGroup, set reference to the original object.</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.type_matches">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.type_matches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">type_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check whether the data type defined by two objects of :class:`SampleDataGroup` is the same.</span>

<span class="sd">        The following is not considered when checking for equality as it is not considered to be part of the</span>
<span class="sd">        type described by the object:</span>

<span class="sd">          - The actual data stored in the data fields</span>
<span class="sd">          - Whether mapping and conversion should be performed</span>
<span class="sd">          - Whether mappings are available for the same fields and whether mappings themselves are the same</span>

<span class="sd">        Important:</span>
<span class="sd">            Note that it is checked whether the fields appear in the same order in the two objects.</span>
<span class="sd">            This is the case if the objects are constructed from the same blueprint (or if they were</span>
<span class="sd">            constructed by adding the individual fields in the same order). This is important as it defines</span>
<span class="sd">            whether the flattened data, e.g. obtained by :meth:`get_data` from one of the objects can be used</span>
<span class="sd">            to fill the data into the other one, e.g. using :meth:`set_data`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value_order</span>

        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))):</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">type_matches</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_types_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">match</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="c1"># Documented as part of the class docstring</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;&#39;name&#39; has unsupported type: `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">type_matches</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Tried to set a data group field &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(fields of type SampleDataGroup), but types do not match.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dali</span><span class="o">.</span><span class="n">data_node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_from_string</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mapping_check_and_convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="SampleDataGroup.set_item_in_path">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_item_in_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_item_in_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Assign a field value at a (nested) path.</span>

<span class="sd">        The path is a sequence of field names/keys. For example, if the path is</span>
<span class="sd">        ``path = (&quot;name_1&quot;, &quot;name_2&quot;, &quot;name_3&quot;)``, the following are equivalent:</span>

<span class="sd">          - ``obj.set_item_in_path(path, value_to_set)``</span>
<span class="sd">          - ``obj[&quot;name_1&quot;][&quot;name_2&quot;][&quot;name_3&quot;] = value_to_set``</span>

<span class="sd">        Important:</span>
<span class="sd">            See the class docstring for details on the assignment behavior.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path of the item to be set.</span>
<span class="sd">            value: Value to be set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;&#39;path&#39; has unsupported type&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;Only setting of children is supported. Therefore, &#39;path&#39; cannot be a tuple/list with length 0.&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The path is a tuple/list, but has only 1 entry. This is equivalent to using a string/number</span>
                <span class="c1"># directly</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># (recursively) use set_item_in_path() and walk the path, until the remaining path is a</span>
                <span class="c1"># single name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">set_item_in_path</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># Documented as part of the class docstring</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;&#39;name&#39; has unsupported type&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dali</span><span class="o">.</span><span class="n">data_node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_string</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

<div class="viewcode-block" id="SampleDataGroup.get_item_in_path">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_item_in_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_item_in_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get a field value at a nested path.</span>

<span class="sd">        The path is a sequence of field names/keys. For example, if ``path = (&quot;name_1&quot;, &quot;name_2&quot;, &quot;name_3&quot;)``,</span>
<span class="sd">        the following are equivalent:</span>

<span class="sd">          - ``value = obj.get_item_in_path(path)``</span>
<span class="sd">          - ``value = obj[&quot;name_1&quot;][&quot;name_2&quot;][&quot;name_3&quot;]``</span>

<span class="sd">        Note:</span>
<span class="sd">            Accessing strings inside the DALI pipeline (except for the input callable/iterable) will return</span>
<span class="sd">            the underlying uint8 tensor instead. Using strings directly is only supported in the input</span>
<span class="sd">            callable/iterable and outside the DALI pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path of the item to get.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Item at ``path``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;&#39;path&#39; has unsupported type&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The path is a tuple/list, but has only 1 entry. This is equivalent to using a string/number</span>
                <span class="c1"># directly</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># (recursively) use get_item_in_path() and walk the path, until the remaining path is a</span>
                <span class="c1"># single name</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">]</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_parent_of_path">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_parent_of_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_of_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get the parent of an element described in path.</span>

<span class="sd">        The following are equivalent:</span>
<span class="sd">          - ``obj.get_parent_of_path(path)``</span>
<span class="sd">          - ``obj.get_item_in_path(path[:-1])``</span>

<span class="sd">        Note:</span>
<span class="sd">            As a parent node cannot be a data field (i.e. a leaf node), the returned value is always a</span>
<span class="sd">            :class:`SampleDataGroup` instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path for which to get the parent.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Parent of the path.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No element &#39;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&#39; is present.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot get parent of element with path len 0, as path len 0 corresponds to the element for &quot;</span>
                <span class="s2">&quot;which the method was called.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_type_of_item_in_path">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_type_of_item_in_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_of_item_in_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span> <span class="nb">type</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get the type of the item at a nested path.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path to the item.</span>

<span class="sd">        See also:</span>
<span class="sd">          - :meth:`SampleDataGroup.get_item_in_path` for a description of the `path` parameter.</span>
<span class="sd">          - :meth:`SampleDataGroup.get_type_of_field` for a description of how type information is returned</span>
<span class="sd">            (which applies to this method as well).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Data type of the field. For data group fields, :class:`SampleDataGroup`. For data fields, the</span>
<span class="sd">            corresponding :class:`nvidia.dali.types.DALIDataType`. If ``path`` is empty, returns</span>
<span class="sd">            ``self``.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;&#39;path&#39; has to be tuple or list&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">to_check_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_check_in</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">res_type</span> <span class="o">=</span> <span class="n">to_check_in</span><span class="o">.</span><span class="n">get_type_of_field</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Path is refering to `self`. As this is a SampleDataGroup, the data type is `SampleDataGroup`</span>
            <span class="n">res_type</span> <span class="o">=</span> <span class="n">SampleDataGroup</span>
        <span class="k">return</span> <span class="n">res_type</span></div>


<div class="viewcode-block" id="SampleDataGroup.path_is_single_name">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.path_is_single_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check if the path given is a single name.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path to check. Can be a single name/key or a sequence of names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``True`` if ``path`` is a single name/key (i.e., a string or integer, not a sequence),</span>
<span class="sd">            ``False`` otherwise.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">is_name</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_name</span></div>


<div class="viewcode-block" id="SampleDataGroup.path_exists">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.path_exists">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check if a field with the given path exists.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether field with given path exists.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remaining_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">remaining_path</span> <span class="o">=</span> <span class="n">remaining_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">path_exists</span><span class="p">(</span><span class="n">remaining_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">exists</span></div>


<div class="viewcode-block" id="SampleDataGroup.path_exists_and_is_data_group_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.path_exists_and_is_data_group_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_exists_and_is_data_group_field</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check if a field with the given path exists and is a data group field.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path to check</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``True`` if field at path exists and is a data group field, ``False`` otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
            <span class="c1"># Path is referring to &#39;self&#39;, which is a SampleDataGroup and therefore a data group field</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get the last name in the path</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="n">last_name</span> <span class="o">=</span> <span class="n">path</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_name</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Get the parent element of the path (is a SampleDataGroup, as it contains children and</span>
                <span class="c1"># therefore is a data group field)</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="c1"># Check whether the element with name `last_name` is a data group field using its parent</span>
                <span class="c1"># node (as the node itself may be a data node).</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">last_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_type_of_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_type_of_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_of_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span> <span class="nb">type</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get type of a field.</span>

<span class="sd">        The type is either expressed as a :class:`nvidia.dali.types.DALIDataType` (data fields) or</span>
<span class="sd">        :class:`SampleDataGroup` (data group fields).</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the field.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Type of the field. For string fields this returns</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.STRING`. Note that this is different from flattened</span>
<span class="sd">            contexts (e.g., :attr:`field_types_flat`), where strings are represented as</span>
<span class="sd">            :class:`nvidia.dali.types.DALIDataType.UINT8`. This is as the flattened data is used internally</span>
<span class="sd">            to pass data between :class:`SampleDataGroup` objects where the object itself cannot be passed and</span>
<span class="sd">            consequently, the string data is passed as stored internally (i.e. the underlying uint8 tensors).</span>
<span class="sd">            Here, the actual type as configured (e.g. by :meth:`add_data_field`) is returned.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_string_no_details">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_string_no_details">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_string_no_details</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get string representing the :class:`SampleDataGroup` instance, omitting details.</span>

<span class="sd">        Omits per-field details such as whether a value is set and whether a mapping is available.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res_str</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_string_with_indent</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">res_str</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Documented as part of the class docstring</span>
        <span class="n">res_str</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_string_with_indent</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">res_str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Documented as part of the class docstring</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">)</span>

<div class="viewcode-block" id="SampleDataGroup.is_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.is_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check whether (self or child) object can be regarded as an array.</span>

<span class="sd">        This is the case if all of the following hold:</span>
<span class="sd">          - The field names have integer numeric names.</span>
<span class="sd">          - Each element in the range ``[0; len(self) - 1]`` is present as a name.</span>
<span class="sd">          - The value order is such that for each element, the name increases by 1, i.e.</span>
<span class="sd">            ``self.contained_top_level_field_names == (0, 1, 2, 3, ...)``.</span>

<span class="sd">        Args:</span>
<span class="sd">            field: If set, perform the check for the named child. Otherwise, check ``self``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the object can be considered an array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">is_array</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleDataGroup.is_data_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.is_data_field_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_data_field_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether (self or child) object is an array whose elements are all data fields (no data group fields).</span>

<span class="sd">        See documentation of :meth:`is_array` for conditions for a data group field to be regarded as an</span>
<span class="sd">        array.</span>

<span class="sd">        Args:</span>
<span class="sd">            field: If set, perform the check for the named child. Otherwise, check ``self``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the object is an array of data fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_field</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">is_data_field_array</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleDataGroup.is_data_group_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.is_data_group_field_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_data_group_field_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether (self or child) object is an array whose elements are all data group fields (no data fields).</span>

<span class="sd">        See documentation of :meth:`is_array` for conditions for a data group field to be regarded as an</span>
<span class="sd">        array.</span>

<span class="sd">        Args:</span>
<span class="sd">            field: If set, perform the check for the named child. Otherwise, check ``self``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the object is an array of data group fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">is_data_group_field_array</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">contained_top_level_field_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the names of the contained top-level fields.</span>

<span class="sd">        The order of the fields corresponds to the order in which they were added.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Names of contained fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field_top_level_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span> <span class="nb">type</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Types of the top-level fields.</span>

<span class="sd">        The order of the fields corresponds to the order in which they were added (and to the order</span>
<span class="sd">        of the elements returned by :attr:`contained_top_level_field_names`).</span>

<span class="sd">        Types fields are :class:`nvidia.dali.types.DALIDataType` instances for data</span>
<span class="sd">        fields and :class:`SampleDataGroup` blueprints for data group fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field_names_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Names of contained data fields flattened (all leaf nodes, not only direct children).</span>

<span class="sd">        Each element corresponds to a data field (leaf node). Original nesting is reflected in the names</span>
<span class="sd">        (concatenated with &quot;.&quot; between parent and child). Numerical names are converted to strings to ensure</span>
<span class="sd">        that they can be used as names in other places (e.g. DALI generic iterator). For example, the numeric</span>
<span class="sd">        name ``5`` would become ``&quot;[5]&quot;``. For example, if there is a data field in the original object in the</span>
<span class="sd">        path ``object[&quot;name_0&quot;][1][&quot;name_2&quot;]``, the name used in the flattened tuple of names would be</span>
<span class="sd">        ``&quot;name_0.[1].name_2&quot;``.</span>

<span class="sd">        The order of the elements corresponds to the order used in :meth:`get_data`, so that the names</span>
<span class="sd">        obtained here correspond to the values obtained there.</span>

<span class="sd">        No names are added for data group fields themselves. If they contain descendants which are data</span>
<span class="sd">        fields, their name will appear in the name of the descendants (before &quot;.&quot;). However, if a data</span>
<span class="sd">        group field does not contain any data field descendants, it will not contribute a name to the output.</span>

<span class="sd">        Note:</span>
<span class="sd">            The names themselves reflect the hierarchy of the data, so that the names are unique, even</span>
<span class="sd">            if there are multiple fields with the same name in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_contained_field_names_flat</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field_types_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Types of contained data fields flattened (all leaf nodes, not only direct children).</span>

<span class="sd">        Each element corresponds to a leaf node.</span>

<span class="sd">        The order of the elements corresponds to the order used in :meth:`get_data`, so that the types</span>
<span class="sd">        obtained here correspond to the values obtained there.</span>

<span class="sd">        No types are added for data group fields themselves. If they contain descendants which are data</span>
<span class="sd">        fields, the types of these descendants will be added. However, if a data group field does not</span>
<span class="sd">        contain any data field descendants, it will not contribute a type to the output.</span>

<span class="sd">        Note:</span>
<span class="sd">            As only the leaf nodes containing data are considered, no entries directly corresponding to data</span>
<span class="sd">            group fields will be added.</span>

<span class="sd">            String fields are represented as :class:`nvidia.dali.types.DALIDataType.UINT8`, matching their</span>
<span class="sd">            in-pipeline representation. Note that this is different from e.g. :meth:`get_type_of_field`,</span>
<span class="sd">            but consistent with :meth:`get_data` (see :meth:`get_data` for details on the rationale).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_contained_types_flat</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="SampleDataGroup.get_data">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_list_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get values of all data fields as a flattened sequence (all leaf nodes, not only direct children).</span>

<span class="sd">        The order of the elements is the order of a depth-first traversal with the order of the children at</span>
<span class="sd">        each node corresponding to the order in which the elements were added (consistent with, e.g.,</span>
<span class="sd">        :attr:`contained_top_level_field_names`). The order is the same as in</span>
<span class="sd">        :attr:`field_names_flat` and :attr:`field_types_flat`, so that these can be used to obtain</span>
<span class="sd">        information about the individual elements of the obtained sequence of values. Only data fields</span>
<span class="sd">        (leaf nodes that are not :class:`SampleDataGroup`) contribute values. Data group fields are not</span>
<span class="sd">        included directly, but their data field descendants contribute values.</span>

<span class="sd">        Note:</span>
<span class="sd">            The tuple returned by this function can be used directly to</span>
<span class="sd">              - Pass parameters from an input callable/iterable to the DALI pipeline.</span>
<span class="sd">              - Return the final output of the DALI pipeline.</span>

<span class="sd">            In these cases, the returned sequence can be used to fill the original data structure</span>
<span class="sd">            (using :meth:`set_data` or :meth:`set_data_from_dali_generic_iterator_output`) into a</span>
<span class="sd">            :class:`SampleDataGroup` blueprint object with the same format as ``self``.</span>

<span class="sd">        Important:</span>
<span class="sd">            For string data fields, the values are the underlying uint8 arrays/tensors (or DataNodes), not</span>
<span class="sd">            Python ``str`` objects (both inside and outside the DALI pipeline). This method is designed to</span>
<span class="sd">            exchange data between :class:`SampleDataGroup` objects and directly returns the underlying data,</span>
<span class="sd">            with the encoded strings. The conversion to Python ``str`` objects is performed when the data is</span>
<span class="sd">            obtained, e.g. using the indexed access operator ``[]`` or :meth:`get_item_in_path`.</span>

<span class="sd">        Args:</span>
<span class="sd">            as_list_type: If ``True``, return a list (tuple otherwise).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sequence of values of all data fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_top_level_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_top_level_field_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="n">res_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">res_i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getitem_without_conversions</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_list_type</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.set_data">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set values of all descendant data fields from a flattened sequence.</span>

<span class="sd">        The sequence needs to contain the data in the same order as indicated by</span>
<span class="sd">        :attr:`field_names_flat`. If the flat data was obtained by :meth:`get_data` from a</span>
<span class="sd">        :class:`SampleDataGroup` object with the same data format as ``self``, this will always be the case.</span>
<span class="sd">        The compatibility between the object from which the flattened data was obtained and this instance can</span>
<span class="sd">        be checked with :meth:`type_matches`.</span>

<span class="sd">        Important:</span>
<span class="sd">            When setting data in this way, no conversions or mappings are applied (both inside and outside</span>
<span class="sd">            the DALI pipeline). This method is designed to exchange data between :class:`SampleDataGroup`</span>
<span class="sd">            objects and expects the data as stored in the :class:`SampleDataGroup` object (i.e., already</span>
<span class="sd">            converted and with mappings applied) as input.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Flat sequence of values to use.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_data_and_get_num_used_data_elements</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.set_data_from_dali_generic_iterator_output">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.set_data_from_dali_generic_iterator_output">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_data_from_dali_generic_iterator_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set values from the output of a DALI generic iterator.</span>

<span class="sd">        The DALI generic iterator refers to :class:`nvidia.dali.plugin.pytorch.DALIGenericIterator` or</span>
<span class="sd">        any other iterator which follows the same interface (tensor types may be from a different framework).</span>

<span class="sd">        The iterator (and therefore, the underlying DALI pipeline) must output the flattened data in the</span>
<span class="sd">        format as this instance (using :meth:`get_data`), with names assigned in the iterator to the</span>
<span class="sd">        individual fields matching :attr:`field_names_flat` of this object. The compatibility</span>
<span class="sd">        between the object from which the flattened data was obtained and this instance can be checked</span>
<span class="sd">        with :meth:`type_matches`.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`get_like_self_filled_from_iterator_output`</span>

<span class="sd">        Note:</span>
<span class="sd">            Values for string fields are uint8 arrays/tensors (not Python strings). For details, see</span>
<span class="sd">            :meth:`get_data`.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Output of the DALI generic iterator.</span>
<span class="sd">            index: Index inside data from which to fill the data.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">name_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_names_flat</span>
        <span class="n">data_as_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data_as_sequence</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.has_child">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.has_child">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check whether a direct child with the given name exists.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the child to check</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether child exists.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.add_data_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.add_data_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_data_field</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Add a data field as a direct child.</span>

<span class="sd">        Data field means that the field contains actual data, i.e. is not another data group field</span>
<span class="sd">        (:class:`SampleDataGroup` instance).</span>

<span class="sd">        Note:</span>
<span class="sd">            If a mapping is defined, it is applied both to strings and to (possibly nested, multi-dimensional)</span>
<span class="sd">            sequences of strings (lists/tuples/arrays). The mapping is a dictionary from original string</span>
<span class="sd">            values to numeric values. The special key ``None`` provides a default value for unmatched inputs.</span>

<span class="sd">            The mapping is only applied when data is assigned inside the input callable/iterable or</span>
<span class="sd">            outside the DALI pipeline. The mapping is not performed for assignments inside the actual</span>
<span class="sd">            DALI pipeline (and setting data there is only supported directly using numerical values).</span>

<span class="sd">        Note:</span>
<span class="sd">            Alternatively to using a mapping, strings can be directly assigned to data fields</span>
<span class="sd">            by setting the data type to :class:`nvidia.dali.types.DALIDataType.STRING`. However,</span>

<span class="sd">              - String processing in this way is only supported inside the input callable/iterable and</span>
<span class="sd">                outside the DALI pipeline, and such strings appear as uint8 tensors inside the DALI</span>
<span class="sd">                pipeline.</span>
<span class="sd">              - Only single strings can be assigned, not sequences of strings (although outputting</span>
<span class="sd">                1D sequences of strings is supported to enable output of batch-wise data).</span>
<span class="sd">              - Often, using a mapping is advantageous to meaningfully process the data in the pipeline</span>
<span class="sd">                and also needs to be performed for other reasons (e.g. to convert class labels from</span>
<span class="sd">                strings to integers to be used in the loss computation).</span>

<span class="sd">            This way of handling strings is e.g. useful to pass sample tags or other high-level</span>
<span class="sd">            descriptors through the pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the field to add</span>
<span class="sd">            type: Type of (the elements of) the field to add. If a mapping is used, this is the type after</span>
<span class="sd">                mapping is applied.</span>
<span class="sd">            mapping: Mapping defining the mapping from input string values to numerical values. The conversion</span>
<span class="sd">                from string to numeric happens at data assignment (if applying mapping is not disabled).</span>
<span class="sd">                ``None`` can be added as a key to the mapping. In this case, the respective value is used if</span>
<span class="sd">                the input string(s) do not match any of the other keys. Mapping is applied both if a single</span>
<span class="sd">                string is assigned, but also for (n-dimensional) sequences of strings. Note that if a mapping</span>
<span class="sd">                is set, numeric values can still be assigned directly to the data field alternatively to</span>
<span class="sd">                strings.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;The method add_data_field() cannot be used to add data group fields (type: SampleDataGroup). &quot;</span>
            <span class="s2">&quot;Use add_data_group_field() instead.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">type</span> <span class="o">!=</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">STRING</span> <span class="ow">or</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Cannot set a mapping for data fields of type types.DALIDataType.STRING&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Field &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; cannot be added as it already exists.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">+</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">+</span> <span class="p">(</span><span class="nb">type</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span></div>


<div class="viewcode-block" id="SampleDataGroup.add_data_group_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.add_data_group_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_data_group_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">blueprint_sample_data_group</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Add a data group field as a direct child.</span>

<span class="sd">        Data group field means a child of the type :class:`SampleDataGroup`, which itself can contain data</span>
<span class="sd">        fields and/or data group fields. Data group fields are used to group elements together logically.</span>

<span class="sd">        ``blueprint_sample_data_group`` acts as a blueprint. A new empty instance with the same format is</span>
<span class="sd">        created and added as the child. Values can be assigned later directly (or via</span>
<span class="sd">        :meth:`set_item_in_path`).</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the new field.</span>
<span class="sd">            blueprint_sample_data_group: :class:`SampleDataGroup` instance describing the field format to add.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Field &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; cannot be added as it already exists.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">+</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">+</span> <span class="p">(</span><span class="n">SampleDataGroup</span><span class="p">,)</span>
        <span class="n">to_add</span> <span class="o">=</span> <span class="n">blueprint_sample_data_group</span><span class="o">.</span><span class="n">get_empty_like_self</span><span class="p">()</span>
        <span class="n">to_add</span><span class="o">.</span><span class="n">set_apply_mapping</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_apply_mapping</span><span class="p">)</span>
        <span class="n">to_add</span><span class="o">.</span><span class="n">set_do_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_convert</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_add</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">SampleDataGroup</span></div>


<div class="viewcode-block" id="SampleDataGroup.add_data_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.add_data_field_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_data_field_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span>
        <span class="n">num_fields</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Add a data field array.</span>

<span class="sd">        Add a child data group field (type :class:`SampleDataGroup`) that contains ``num_fields`` elements,</span>
<span class="sd">        each with the type and mapping defined here. Elements are added with integer names from ``0`` to</span>
<span class="sd">        ``num_fields - 1``, so the child behaves like an array.</span>

<span class="sd">        Note:</span>
<span class="sd">            If a blueprint of the array is already created as another, independent  blueprint, you can use</span>
<span class="sd">            :meth:`add_data_group_field` to add the blueprint to this object.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`add_data_group_field_array`</span>
<span class="sd">            :meth:`create_data_field_array`</span>
<span class="sd">            :meth:`create_data_group_field_array`</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the array data group field to add</span>
<span class="sd">            type: Type of the fields to add to the array data group field</span>
<span class="sd">            num_fields: Number of fields to add to the array data group field</span>
<span class="sd">            mapping: Optional mapping for the fields (see :meth:`add_data_field` for details on mappings).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">data_group_to_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_data_field_array</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">num_fields</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_data_group_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data_group_to_add</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.add_data_group_field_array">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.add_data_group_field_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_data_group_field_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">blueprint_sample_data_group</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">,</span> <span class="n">num_fields</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Add a data group field array.</span>

<span class="sd">        Add a child data group field (type :class:`SampleDataGroup`) that contains ``num_fields`` elements,</span>
<span class="sd">        each matching the provided blueprint. Elements are added with integer names from ``0`` to</span>
<span class="sd">        ``num_fields - 1`` so the child behaves like an array.</span>

<span class="sd">        Note:</span>
<span class="sd">            If a blueprint of the array is already created as another, independent  blueprint, you can use</span>
<span class="sd">            :meth:`add_data_group_field` to add the blueprint to this object.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`add_data_field_array`</span>
<span class="sd">            :meth:`create_data_field_array`</span>
<span class="sd">            :meth:`create_data_group_field_array`</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the array data group field to add</span>
<span class="sd">            blueprint_sample_data_group: :class:`SampleDataGroup` describing the element format (each</span>
<span class="sd">                element is initialized from ``get_empty_like_self()`` of the blueprint).</span>
<span class="sd">            num_fields: Number of elements to add.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">data_group_to_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_data_group_field_array</span><span class="p">(</span><span class="n">blueprint_sample_data_group</span><span class="p">,</span> <span class="n">num_fields</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_data_group_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data_group_to_add</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.remove_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.remove_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Delete the direct child with the given name.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`remove_all_occurrences`</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the child to remove.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot delete field &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; as it is not present.&quot;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.remove_all_occurrences">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.remove_all_occurrences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_all_occurrences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_to_remove</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Remove all fields with a given name.</span>

<span class="sd">        All fields with a given name are removed in the tree of which ``self`` is the root, i.e. of this node</span>
<span class="sd">        and its descendants.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`remove_field`</span>

<span class="sd">        Args:</span>
<span class="sd">            name_to_remove: Name of the field(s) to remove</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># If a child with the matching name exists, remove it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">name_to_remove</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_field</span><span class="p">(</span><span class="n">name_to_remove</span><span class="p">)</span>

        <span class="c1"># Also make sure to remove in children (recursively)</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove_all_occurrences</span><span class="p">(</span><span class="n">name_to_remove</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.find_all_occurrences">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.find_all_occurrences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_all_occurrences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_to_find</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Find all occurrences of fields with a given name.</span>

<span class="sd">        The search is performed in the tree where ``self`` is the root, i.e. of this node and its descendants.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`get_num_occurrences`</span>

<span class="sd">        Args:</span>
<span class="sd">            name_to_find: Name of the field(s) to find</span>

<span class="sd">        Returns:</span>
<span class="sd">            Paths to the found fields. If none were found, an empty tuple is returned. The individual paths</span>
<span class="sd">            are themselves tuples. For example, the path ``(&quot;name_1&quot;, &quot;name_2&quot;, &quot;name_3&quot;)`` would denote the</span>
<span class="sd">            element ``self[&quot;name_1&quot;][&quot;name_2&quot;][&quot;name_3&quot;]``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_all_occurrences_rec</span><span class="p">(</span><span class="n">name_to_find</span><span class="p">,</span> <span class="p">[],</span> <span class="n">res</span><span class="p">)</span>
        <span class="c1"># convert the individual paths to tuples</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_num_occurrences">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_num_occurrences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_occurrences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_to_find</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get the number of occurrences of fields with a given name.</span>

<span class="sd">        Returns the number of occurrences in the tree where ``self`` is the root, i.e. of this node and its</span>
<span class="sd">        descendants.</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`find_all_occurrences`</span>

<span class="sd">        Args:</span>
<span class="sd">            name_to_find: Name to search for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of occurrences</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">occurences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">name_to_find</span><span class="p">)</span>
        <span class="n">num_occ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">occurences</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_occ</span></div>


<div class="viewcode-block" id="SampleDataGroup.change_type_of_data_and_remove_data">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.change_type_of_data_and_remove_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_type_of_data_and_remove_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">new_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">],</span>
        <span class="n">new_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the type of a child field and remove its data.</span>

<span class="sd">        The data is removed as it is incompatible with the new type. Note that removing the data means</span>
<span class="sd">        resetting the reference, not actively deleting the data.</span>

<span class="sd">        Example:</span>
<span class="sd">            A typical use case would be:</span>

<span class="sd">            1) Get the data of which the type should be changed, e.g.: ``data = obj[&quot;name&quot;]``</span>
<span class="sd">            2) Change the data type</span>

<span class="sd">                a) Change the data type as stored in the structure, e.g.:</span>
<span class="sd">                   ``obj.change_type_of_data_and_remove_data(&quot;name&quot;, dali.types.DALIDataType.FLOAT)``</span>
<span class="sd">                b) Convert the actual data, e.g.: ``data = dali.fn.cast(data, dtype=types.DALIDataType.FLOAT)``</span>
<span class="sd">            3) Write data back, e.g.: ``obj[&quot;name&quot;] = data``</span>

<span class="sd">        Note that instead of ``&quot;name&quot;``, a nested path can be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Either a child name or a nested path (sequence of names).</span>
<span class="sd">            new_type: For data fields, a :class:`types.DALIDataType`. For data group fields, a</span>
<span class="sd">                :class:`SampleDataGroup` used as a blueprint describing the new format.</span>
<span class="sd">            new_mapping: New mapping for data fields (see :meth:`add_data_field`). Must be ``None`` for data</span>
<span class="sd">                group fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">old_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="o">==</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_element</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;Data group field array type can only be changed to another data group field type and data field &quot;</span>
            <span class="s2">&quot;type only to another data field type.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">new_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;When changing type of data group field (i.e. SampleDataGroup node), `new_mapping` has to be &quot;</span>
                <span class="s2">&quot;`None`&quot;</span>
            <span class="p">)</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">path</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_change_data_group_field_type_to</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_is_single_name</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">path</span>
            <span class="n">element_idx</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_value_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="n">value_order_to_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">_value_order</span><span class="p">)</span>
            <span class="n">value_order_to_set</span><span class="p">[</span><span class="n">element_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value_order_to_set</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">type_order_to_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">_types_order</span><span class="p">)</span>
            <span class="n">type_order_to_set</span><span class="p">[</span><span class="n">element_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_type</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">type_order_to_set</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_type</span>

            <span class="k">if</span> <span class="n">new_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">_mappings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_mapping</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">_mappings</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">parent</span><span class="o">.</span><span class="n">_mappings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_flat_index_first_discrepancy_to_other">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_flat_index_first_discrepancy_to_other">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_flat_index_first_discrepancy_to_other</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the first flat index where two instances differ in field structure, name, or type.</span>

<span class="sd">        Compares flattened field names and types (see :attr:`field_names_flat`,</span>
<span class="sd">        :attr:`field_types_flat`). The flattened names include full paths, making structural differences</span>
<span class="sd">        visible. Empty sample data group nodes (no data field descendants) are ignored.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: Other SampleDataGroup instance to compare to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Index where the first difference is present, or -1 if there are no differences. Note that</span>
<span class="sd">            string fields are compared as :class:`nvidia.dali.types.DALIDataType.UINT8` in the flattened</span>
<span class="sd">            types, matching :attr:`field_types_flat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">self_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_types_flat</span>
        <span class="n">self_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_names_flat</span>

        <span class="n">other_types</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">field_types_flat</span>
        <span class="n">other_names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">field_names_flat</span>

        <span class="n">types_match</span> <span class="o">=</span> <span class="n">self_types</span> <span class="o">==</span> <span class="n">other_types</span>
        <span class="n">names_match</span> <span class="o">=</span> <span class="n">self_names</span> <span class="o">==</span> <span class="n">other_names</span>
        <span class="k">if</span> <span class="n">types_match</span> <span class="ow">and</span> <span class="n">names_match</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">self_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_types</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">self_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">self_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other_types</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">i</span>

        <span class="c1"># If none of the other return statements were executed, this means that the length is different.</span>
        <span class="c1"># In this case, &#39;length&#39; is the first index in which the SampleDataGroup instances differ, as this is</span>
        <span class="c1"># the length of the shorter one and therefore points to the first element in the long one for which</span>
        <span class="c1"># there is no correspondence in the short one.</span>
        <span class="k">return</span> <span class="n">length</span></div>


<div class="viewcode-block" id="SampleDataGroup.ensure_uniform_size_in_batch">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.ensure_uniform_size_in_batch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_uniform_size_in_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;For each data field, ensure uniform size in batch by padding with ``fill_value``.</span>

<span class="sd">        This is equivalent to calling ``dali.fn.pad(field_values)`` for all contained data fields (in this</span>
<span class="sd">        data group field, and its descendants).</span>

<span class="sd">        Warning:</span>
<span class="sd">          - This method needs to be called inside the DALI pipeline (except the input callable/iterable).</span>
<span class="sd">          - Scalar (i.e. 0D) tensors are not supported. If such tensors are present, an error will be raised.</span>

<span class="sd">        Args:</span>
<span class="sd">            fill_value: Fill value to be used for the padded region.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="c1"># Recursively apply to SampleDataNode children</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ensure_uniform_size_in_batch</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.ensure_uniform_size_in_batch_for_all_strings">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.ensure_uniform_size_in_batch_for_all_strings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_uniform_size_in_batch_for_all_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Ensure uniform size in batch for all string data fields.</span>

<span class="sd">        This is useful before outputting from the DALI pipeline in a format that expects uniform size.</span>
<span class="sd">        A padding with 0-values is performed for all string data fields. This is done for all contained</span>
<span class="sd">        string data fields (in this data group field, and its descendants).</span>

<span class="sd">        Note:</span>
<span class="sd">            When obtaining the data as strings, the padding is removed and only the actual data is returned.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ensure_uniform_size_in_batch_for_all_strings</span><span class="p">()</span></div>


<div class="viewcode-block" id="SampleDataGroup.is_data_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.is_data_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_data_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check whether a child field is a data field.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the child field to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the child field is a data field (contains values) as opposed to a data group field</span>
<span class="sd">            (field of type :class:`SampleDataGroup`).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No element with name &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is present.&quot;</span><span class="p">)</span>
        <span class="n">is_leaf</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_leaf</span></div>


<div class="viewcode-block" id="SampleDataGroup.is_data_group_field">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.is_data_group_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_data_group_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check whether a child field is a data group field.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of the child field to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the child field is a data group field (field of type :class:`SampleDataGroup`).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleDataGroup.to_dictionary">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.to_dictionary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get a nested dictionary with the same (nested) data structure and contained values.</span>

<span class="sd">        This and descendants :class:`SampleDataGroup` objects are converted to :class:`dict` objects.</span>
<span class="sd">        Contained strings are returned as Python strings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting dictionary.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.get_numpy_type_for_dali_type">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.get_numpy_type_for_dali_type">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_numpy_type_for_dali_type</span><span class="p">(</span><span class="n">dali_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get the numpy dtype corresponding to a DALI data type.</span>

<span class="sd">        Note:</span>
<span class="sd">            Only numeric and boolean DALI types are supported. A ``ValueError`` is raised</span>
<span class="sd">            for unsupported types.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dali_type</span> <span class="ow">in</span> <span class="n">SampleDataGroup</span><span class="o">.</span><span class="n">_type_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The DALI type (</span><span class="si">{</span><span class="n">dali_type</span><span class="si">}</span><span class="s2">) does not have a corresponding numpy type set in SampleDataGroup&quot;</span>
            <span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">SampleDataGroup</span><span class="o">.</span><span class="n">_type_mapping</span><span class="p">[</span><span class="n">dali_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SampleDataGroup.check_has_children">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/pipeline.html#accvlab.dali_pipeline_framework.pipeline.SampleDataGroup.check_has_children">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_has_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_field_children</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_group_field_children</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_field_array_children</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_group_field_array_children</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">current_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check that required children are present; raise ``ValueError`` if not.</span>

<span class="sd">        Convenience helper for validating presence and kinds of children.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_field_children: Required child names which must be data fields.</span>
<span class="sd">            data_group_field_children: Required child names which must be data group fields.</span>
<span class="sd">            data_field_array_children: Required child names which must be arrays of data fields.</span>
<span class="sd">            data_group_field_array_children: Required child names which must be arrays of data group fields.</span>
<span class="sd">            current_name: Name of the current element. Optional, only used to provide clearer error messages.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If a required child is not present or is not of the expected type.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">current_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_to_insert</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_to_insert</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">current_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

        <span class="k">if</span> <span class="n">data_field_children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_field_children</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">data_field_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_field_children</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dfc</span> <span class="ow">in</span> <span class="n">data_field_children</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">dfc</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2"> does not have child `</span><span class="si">{</span><span class="n">dfc</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_field</span><span class="p">(</span><span class="n">dfc</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2">: child `</span><span class="si">{</span><span class="n">dfc</span><span class="si">}</span><span class="s2">` is not a data field.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_group_field_children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_group_field_children</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">data_group_field_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_group_field_children</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dgfc</span> <span class="ow">in</span> <span class="n">data_group_field_children</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">dgfc</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2"> does not have child `</span><span class="si">{</span><span class="n">dgfc</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">dgfc</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2">: child `</span><span class="si">{</span><span class="n">dgfc</span><span class="si">}</span><span class="s2">` is not a data group field.&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">data_field_array_children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_field_array_children</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">data_field_array_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_field_array_children</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dfca</span> <span class="ow">in</span> <span class="n">data_field_array_children</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">dfca</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2"> does not have child `</span><span class="si">{</span><span class="n">dfca</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">dfca</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">dfca</span><span class="p">]</span><span class="o">.</span><span class="n">is_data_field_array</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2">: child `</span><span class="si">{</span><span class="n">dfca</span><span class="si">}</span><span class="s2">` is not a data field array.&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">data_group_field_array_children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_group_field_array_children</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">data_group_field_array_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_group_field_array_children</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dgfca</span> <span class="ow">in</span> <span class="n">data_group_field_array_children</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child</span><span class="p">(</span><span class="n">dgfca</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2"> does not have child `</span><span class="si">{</span><span class="n">dgfca</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_data_group_field</span><span class="p">(</span><span class="n">dgfca</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">dgfca</span><span class="p">]</span><span class="o">.</span><span class="n">is_data_group_field_array</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Data Group field </span><span class="si">{</span><span class="n">name_to_insert</span><span class="si">}</span><span class="s2">: child `</span><span class="si">{</span><span class="n">dgfca</span><span class="si">}</span><span class="s2">` is not a data group field array.&quot;</span>
                    <span class="p">)</span></div>


    <span class="c1"># ----- Private helper functions from here on -----</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_string_with_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">with_details</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">ident_string</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">indent</span>
        <span class="n">res_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">space_details</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="n">res_str</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ident_string</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">ident_string</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;{&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_to_string_with_indent</span><span class="p">(</span><span class="n">indent</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">with_details</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">res_str</span> <span class="o">+=</span> <span class="n">ident_string</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ident_string</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">])</span><span class="si">}{</span><span class="n">space_details</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;(is set: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="si">}</span><span class="s2">; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;mapping available: </span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">with_details</span>
                    <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">res_str</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_contained_field_names_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_top_level_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_top_level_field_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">prefix_to_add</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prefix_to_add</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">].&quot;</span>
                <span class="n">res_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_get_contained_field_names_flat</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">prefix_to_add</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">res_i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">name_to_use</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name_to_use</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_to_use</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_contained_types_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_top_level_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_top_level_field_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="n">res_i</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_get_contained_types_flat</span><span class="p">()</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">res_i</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_data_and_get_num_used_data_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">curr_element</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_top_level_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contained_top_level_field_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="n">num_elements_used</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_set_data_and_get_num_used_data_elements</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">curr_element</span><span class="p">:])</span>
                <span class="n">curr_element</span> <span class="o">+=</span> <span class="n">num_elements_used</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_without_conversions</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">curr_element</span><span class="p">])</span>
                <span class="n">curr_element</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curr_element</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_all_occurrences_rec</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_to_find</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">results_ref</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name_to_find</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">:</span>
            <span class="c1"># Copy necessary as otherwise, the prefix used by the outer recursion levels would be altered</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_to_find</span><span class="p">)</span>
            <span class="n">results_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
                <span class="c1"># Copy prefix to not modify the original, which will is still needed by the caller</span>
                <span class="n">prefix_for_next</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="c1"># Include the current child which which we re going to call `_find_all_occurrences_rec(...)`</span>
                <span class="c1"># to the prefix</span>
                <span class="n">prefix_for_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="c1"># Call `_find_all_occurrences_rec(...)` of the current child</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_find_all_occurrences_rec</span><span class="p">(</span><span class="n">name_to_find</span><span class="p">,</span> <span class="n">prefix_for_next</span><span class="p">,</span> <span class="n">results_ref</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_copy_except_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
        <span class="c1"># First, make a shallow copy to obtain the object itself.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Then, deep copy the individual properties where possible &amp; needed</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_mappings</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_value_order</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_order</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_types_order</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_order</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_types</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">)</span>
        <span class="c1"># &#39;res._values&#39; should not be filled in this function. Set it to &#39;None&#39;</span>
        <span class="c1"># as otherwise, it is a shallow copy of &#39;self._values&#39;</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_mapping_check_and_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_apply_mapping</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mapping_if_set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_or_convert_types</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_mapping_if_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SampleDataGroup</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Mapping cannot be applied inside the DALI pipeline; call &quot;</span>
                    <span class="s2">&quot;set_apply_mapping(False) first to disable. Proceeding without mapping.&quot;</span>
                <span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">get_mapped</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mappings</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_or_convert_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># Get the expected type of the data field</span>
        <span class="n">dali_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># Only perform runtime type checking inside the DALI pipeline when explicitly enabled.</span>
        <span class="c1"># Skipping this preserves tensor layout metadata (important for steps like AxesLayoutSetter).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_check_type</span><span class="p">:</span>
            <span class="c1"># Support both regular and debug-mode DALI nodes</span>
            <span class="n">is_data_node</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dali</span><span class="o">.</span><span class="n">data_node</span><span class="p">,</span> <span class="s2">&quot;DataNode&quot;</span><span class="p">,</span> <span class="p">()))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">dali</span><span class="p">,</span> <span class="s2">&quot;_debug_mode&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">()),</span> <span class="s2">&quot;DataNodeDebug&quot;</span><span class="p">,</span> <span class="p">())</span>
            <span class="p">)</span>

            <span class="c1"># If we are inside the DALI pipeline, we need to check that the data type is correct (regardless of</span>
            <span class="c1"># the `_do_convert` flag).</span>
            <span class="k">if</span> <span class="n">is_data_node</span><span class="p">:</span>
                <span class="c1"># Ensure the check op is part of the graph by using its output</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">check_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_mapping</span><span class="p">[</span><span class="n">dali_type</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_convert</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="c1"># If the set element is a data group, there is no conversion needed</span>
        <span class="k">if</span> <span class="n">dali_type</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="n">np_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_mapping</span><span class="p">[</span><span class="n">dali_type</span><span class="p">]</span>

        <span class="c1"># note that `numbers.Number` includes Booleans, but not `np.bool_`, so do not check for python</span>
        <span class="c1"># booleans explicitly, but check for `np.bool_`</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_from_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">as_bytes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">as_bytes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a string or a DataNode, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dali</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">np_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">np_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">np_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected a numpy array, cupy array, a torch tensor, or a DataNode, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If this is an encoded string, the first element will contain a number</span>
        <span class="c1"># If it is a (possibly nested) sequence of strings, the first element will be again a sequence (and</span>
        <span class="c1"># the else branch is executed)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">np_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">as_bytes</span> <span class="o">=</span> <span class="n">np_data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">as_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Elements are themseves (spossibly nested) sequences of strings (see comment above `if``). In</span>
            <span class="c1"># this case, process each entry (recursively, until the actual strings are reached).</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_string</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np_data</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_change_data_group_field_type_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Called _change_data_group_field_type_to() for a non-SampleDataGroup element.&quot;</span><span class="p">)</span>
        <span class="n">blueprint</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_empty_like_self</span><span class="p">()</span>
        <span class="n">blueprint</span><span class="o">.</span><span class="n">set_apply_mapping</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_apply_mapping_if_set</span><span class="p">)</span>
        <span class="n">blueprint</span><span class="o">.</span><span class="n">set_do_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_convert</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">blueprint</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setitem_without_conversions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">type_matches</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Tried to set a data group field &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; (fields of type SampleDataGroup), but types &quot;</span>
                    <span class="s2">&quot;do not match.&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getitem_without_conversions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No field with name &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, NVIDIA Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>