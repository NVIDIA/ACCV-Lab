

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>accvlab.dali_pipeline_framework.processing_steps.affine_transformer &mdash; ACCV-Lab 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=9282052d" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ACCV-Lab
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">General Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../project_overview/README.html">ACCV-Lab Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides_index.html">Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contained Packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/on_demand_video_decoder/docs/index.html">On Demand Video Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/batching_helpers/docs/index.html">Batching Helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/index.html">DALI Pipeline Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/draw_heatmap/docs/index.html">Draw Heatmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contained_package_docs_mirror/optim_test_tools/docs/index.html">Optimization Testing Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ACCV-Lab</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">accvlab.dali_pipeline_framework.processing_steps.affine_transformer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for accvlab.dali_pipeline_framework.processing_steps.affine_transformer</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2025, NVIDIA CORPORATION &amp; AFFILIATES. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># Used to enable type hints using a class type inside the implementation of that class itself.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.fn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.math</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.types</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nvidia.dali.data_node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">node</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">nvidia.dali.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">do_not_convert</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">override</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">override</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..pipeline.sample_data_group</span><span class="w"> </span><span class="kn">import</span> <span class="n">SampleDataGroup</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..operators_impl.python_operator_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">apply_transform_to_points</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..operators_impl.numba_operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">apply_matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..internal_helpers</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_as_data_node</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">PipelineStepBase</span>


<div class="viewcode-block" id="AffineTransformer">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AffineTransformer</span><span class="p">(</span><span class="n">PipelineStepBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Apply affine augmentations (translation, scaling, rotation, shearing) to images, and update</span>
<span class="sd">    associated geometry (points, projection matrices) consistently.</span>

<span class="sd">    This step can process one or multiple images, as well as point sets and projection matrices. It</span>
<span class="sd">    expects image data fields and sibling image-size fields in the input (see :class:`SampleDataGroup`).</span>
<span class="sd">    Optionally, names of point-set and projection-matrix fields can be provided. Multiple instances may</span>
<span class="sd">    be present; all matching occurrences are processed. If multiple images are found, each must have a</span>
<span class="sd">    sibling size field, and the sizes must match.</span>

<span class="sd">    The same transformation is applied to all matched images. If different images require different</span>
<span class="sd">    transformations, create multiple instances of this step and apply them to different sub-trees (see</span>
<span class="sd">    :class:`GroupToApplyToSelectedStepBase`).</span>

<span class="sd">    Projection geometry represented as intrinsics and extrinsics should be handled by passing only the</span>
<span class="sd">    intrinsics matrix to this step; extrinsics are unaffected by an image-plane affine transform.</span>
<span class="sd">    Note that apart from true projection matrices, any matrices can be handled which transform points from</span>
<span class="sd">    a different coordinate system into the image coordinate system.</span>

<span class="sd">    The affine transform conceptually moves image content within a fixed viewport. For example, a</span>
<span class="sd">    translation to the right shifts the content rightward and exposes a border on the left. Scaling does</span>
<span class="sd">    not change the viewport size (pixel resolution), so upscaling reveals only the center region, while</span>
<span class="sd">    downscaling fills only part of the viewport.</span>

<span class="sd">    After augmentation, a resize to the requested output resolution is applied if needed. When aspect</span>
<span class="sd">    ratios differ, the adjustment is controlled by :class:`AffineTransformer.ResizingMode` and</span>
<span class="sd">    :class:`AffineTransformer.ResizingAnchor`. Note that this resizing is independent of the affine</span>
<span class="sd">    transformation (where scaling leaves the viewport unchanged), and can be used to change the resolution</span>
<span class="sd">    and aspect ratio of the image.</span>

<span class="sd">    The overall transform is built as a chain of steps (see :class:`AffineTransformer.TransformationStep`</span>
<span class="sd">    and subclasses). :class:`AffineTransformer.Selection` allows probabilistic branching. Some steps that</span>
<span class="sd">    depend on alignments cannot follow incompatible steps (e.g., rotation or shearing). These constraints</span>
<span class="sd">    are validated at construction, and include incompatible steps anywhere in the chain before the step</span>
<span class="sd">    (including potentially applied probabilistic branches).</span>

<span class="sd">    All steps that require a reference point (e.g., rotation, scaling) use the viewport center.</span>

<span class="sd">    The composed augmentation and resize are combined to a single image resampling step to minimize,</span>
<span class="sd">    which is advantageous both for quality of the final image and runtime.</span>

<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="AffineTransformer.TransformationStep">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.TransformationStep">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">TransformationStep</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Step used to build up the overall affine transformation to apply. Each step is processed in sequence and with a given probability.</span>

<span class="sd">        Probabilistic branching possible by using the ``AffineTransformer.Selection`` (also see documentation for that step).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability with which this step is applied</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">image_hw</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
            <span class="c1"># Note: This docstring should not be shown, but `:meta private` does not work for private methods.</span>
            <span class="c1"># Comment it out, but do not delete (for in-code documentation).</span>
            <span class="c1"># &#39;&#39;&#39;</span>
            <span class="c1"># Update current transformation matrix (corresponding to previous steps) with this step.</span>
            <span class="c1">#</span>
            <span class="c1"># Args:</span>
            <span class="c1">#     prior_trafo: Transforamtion matrix for previous steps or None if this is the first transformation</span>
            <span class="c1">#     image_hw: Input image height and width</span>
            <span class="c1">#</span>
            <span class="c1"># Returns:</span>
            <span class="c1">#     Transformation matrix corresponding to previous and current steps</span>
            <span class="c1">#</span>
            <span class="c1"># :meta private:</span>
            <span class="c1"># &#39;&#39;&#39;</span>

            <span class="k">if</span> <span class="n">prior_trafo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trafo</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span>
                    <span class="n">fdata</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trafo</span> <span class="o">=</span> <span class="n">prior_trafo</span>
            <span class="c1"># trafo = fn.cast([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]], dtype=types.)</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">draw</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">:</span>
                <span class="n">trafo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">trafo</span>

        <span class="nd">@abstractmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;Validate that no incompatible prior steps exist and record this step&#39;s type.</span>

<span class="sd">            If a step itself aggregates other steps (e.g., :class:`AffineTransformer.Selection`), the</span>
<span class="sd">            types of all potentially applied steps must be included.</span>

<span class="sd">            Args:</span>
<span class="sd">                prev_types: Types of previously (potentially) applied steps.</span>

<span class="sd">            Returns:</span>
<span class="sd">                Types of potentially taken steps up to and including this step.</span>

<span class="sd">            :meta private:</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">pass</span>

        <span class="nd">@abstractmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;Apply this step to update the current transformation matrix.</span>

<span class="sd">            Note:</span>
<span class="sd">                The :meth:`AffineTransformer.TransformationStep.__call__` method initializes the matrix (if</span>
<span class="sd">                needed) and handles probabilistic execution, so here</span>
<span class="sd">                  - ``prior_trafo`` is always provided</span>
<span class="sd">                  - the step should be executed without any further checks regarding the execution probability</span>

<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">pass</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_get_random_in_range</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">min</span> <span class="o">==</span> <span class="nb">max</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">min</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>
                <span class="nb">max</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_get_center_xy</span><span class="p">(</span><span class="n">image_hw</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.Translation">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.Translation">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">Translation</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform a randomized translation (in a given range).&#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">min_xy</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_xy</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to apply step.</span>
<span class="sd">                min_xy: Minimum shift in x and y. If ``max_xy`` is not set, a shift of exactly ``min_xy`` is</span>
<span class="sd">                    performed instead of selecting at random from a range.</span>
<span class="sd">                max_xy: Maximum shift in x and y.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_xy</span> <span class="o">=</span> <span class="n">min_xy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_xy</span> <span class="o">=</span> <span class="n">max_xy</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_xy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translation_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">translation_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span>
                    <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">translation_x</span><span class="p">,</span> <span class="n">translation_y</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.ShiftInsideOriginalImage">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.ShiftInsideOriginalImage">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ShiftInsideOriginalImage</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform a random translation. The shift is selected so that the viewport is filled with the image.</span>

<span class="sd">        This is only possible if the image is larger (i.e. previously scaled up) or equal to the viewport.</span>
<span class="sd">        If this is not the case, this step does nothing.</span>

<span class="sd">        The shift is computed and performed independently for x- and y-directions. This means that if the</span>
<span class="sd">        image is larger than the viewport in one dimension and smaller in the other one (e.g. due to</span>
<span class="sd">        non-uniform scaling), this step will be performed in the dimension where the image is larger than</span>
<span class="sd">        the viewport.</span>

<span class="sd">        Also, if the image is larger than the viewport, this step will bring back the image</span>
<span class="sd">        to cover the whole viewport if it was previously moved out of it.</span>

<span class="sd">        This step cannot be performed if a rotation and/or shearing was potentially performed before.</span>

<span class="sd">        Args:</span>
<span class="sd">            prob: Probability to apply step.</span>
<span class="sd">            shift_x: Whether to apply in x-direction.</span>
<span class="sd">            shift_y: Whether to apply in y-direction.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">shift_x</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to apply step.</span>
<span class="sd">                shift_x: Whether to apply in x-direction.</span>
<span class="sd">                shift_y: Whether to apply in y-direction.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_x</span> <span class="o">=</span> <span class="n">shift_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_y</span> <span class="o">=</span> <span class="n">shift_y</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="nd">@do_not_convert</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">get_min_max_shifts</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
                <span class="n">upper_left_orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">prior_trafo</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">lower_right_orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">prior_trafo</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">min_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">max_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

                <span class="c1"># For each dimension, check which point is the lower and which the higher cordinate (may be flipped)</span>
                <span class="n">min_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">max_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                        <span class="n">min_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">max_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">min_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">max_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>

                    <span class="n">min_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">min_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                    <span class="n">max_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">min_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">min_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">min_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">max_shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

                <span class="k">return</span> <span class="n">min_shift</span><span class="p">,</span> <span class="n">max_shift</span>

            <span class="n">min_shift</span><span class="p">,</span> <span class="n">max_shift</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span>
                <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">get_min_max_shifts</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_x</span> <span class="ow">and</span> <span class="n">min_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">x_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="n">min_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_shift</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_y</span> <span class="ow">and</span> <span class="n">min_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">y_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="n">min_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">Rotation</span> <span class="ow">in</span> <span class="n">prev_types</span> <span class="ow">or</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">Shearing</span> <span class="ow">in</span> <span class="n">prev_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot perform `ShiftInsideOriginalImage` if rotation or shearing are (potentially) performed before.&quot;</span>
                <span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.ShiftToAlignWithOriginalImageBorder">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.ShiftToAlignWithOriginalImageBorder">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ShiftToAlignWithOriginalImageBorder</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Translate the image so that it is aligned to a border of the viewport.</span>

<span class="sd">        The border to align to can be selected on construction.</span>

<span class="sd">        This step cannot be performed if a rotation and/or shearing was potentially performed before.</span>

<span class="sd">        &#39;&#39;&#39;</span>

<div class="viewcode-block" id="AffineTransformer.ShiftToAlignWithOriginalImageBorder.Border">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.ShiftToAlignWithOriginalImageBorder.Border">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">Border</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;Enumeration for viewport borders to align to&#39;&#39;&#39;</span>

            <span class="n">TOP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">LEFT</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">BOTTOM</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">3</span></div>


        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">border</span><span class="p">:</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">ShiftToAlignWithOriginalImageBorder</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform step.</span>
<span class="sd">                border: Border of the viewport to align image to.</span>

<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_border</span> <span class="o">=</span> <span class="n">border</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="nd">@do_not_convert</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">get_min_max_coords</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
                <span class="n">upper_left_orig</span> <span class="o">=</span> <span class="n">prior_trafo</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">lower_right_orig</span> <span class="o">=</span> <span class="n">prior_trafo</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># For each dimension, check which point is the lower and which the higher cordinate (may be flipped)</span>
                <span class="n">min_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">max_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                        <span class="n">min_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">max_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">min_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_right_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="n">max_coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper_left_orig</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">min_coords</span><span class="p">,</span> <span class="n">max_coords</span>

            <span class="n">min_coords</span><span class="p">,</span> <span class="n">max_coords</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span>
                <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">get_min_max_coords</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_border</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Border</span><span class="o">.</span><span class="n">TOP</span><span class="p">:</span>
                <span class="n">translation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">min_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_border</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Border</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span>
                <span class="n">translation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="o">-</span><span class="n">min_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_border</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Border</span><span class="o">.</span><span class="n">BOTTOM</span><span class="p">:</span>
                <span class="n">translation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_border</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Border</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span>
                <span class="n">translation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Border type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_border</span><span class="si">}</span><span class="s2"> not supported&quot;</span><span class="p">)</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">translation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">Rotation</span> <span class="ow">in</span> <span class="n">prev_types</span> <span class="ow">or</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">Shearing</span> <span class="ow">in</span> <span class="n">prev_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot perform `ShiftToAlignWithOriginalImageBorder` if rotation or shearing are (potentially) performed before.&quot;</span>
                <span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.Rotation">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.Rotation">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">Rotation</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform a rotation.&#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">min_rot</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_rot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform step.</span>
<span class="sd">                min_rot: Minimum rotation to perform. If ``max_rot`` is not set, this rotation is performed</span>
<span class="sd">                    instead of selecting a rotation value randomly from the range.</span>
<span class="sd">                max_rot: Maximum rotation to perform.</span>

<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_rot</span> <span class="o">=</span> <span class="n">min_rot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_rot</span> <span class="o">=</span> <span class="n">max_rot</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_center_xy</span><span class="p">(</span><span class="n">image_hw</span><span class="p">)</span>
            <span class="c1"># Note that in both of the following cases, the angle is negated to ensure that positive angles</span>
            <span class="c1"># correspond to anti-clockwise rotation in the image. Due to the coordinate system used for</span>
            <span class="c1"># images, rotation with positive angle will rotate the image clockwise (due to y pointing down).</span>
            <span class="c1"># This is not the common convention when rotating images. To ensure that positive angles</span>
            <span class="c1"># correspond to anti-clockwise rotation, the angle is negated. This is also done for the case</span>
            <span class="c1"># of random angles to ensure that the minimum and maximum angles are always in the expected</span>
            <span class="c1"># direction.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_rot</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">rotation</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_rot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rot</span><span class="p">)</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">rotation</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.UniformScaling">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.UniformScaling">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">UniformScaling</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform uniform scaling (i.e. identical scaling factor in both x- and y-dimensions).&#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">min_scaling</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_scaling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform step.</span>
<span class="sd">                min_scaling: Minimum scaling factor. If ``max_scaling`` is not set, this factor is always</span>
<span class="sd">                    applied instead of selecting a random factor from the range.</span>
<span class="sd">                max_scaling: Maximum scaling factor.</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_scaling</span> <span class="o">=</span> <span class="n">min_scaling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling</span> <span class="o">=</span> <span class="n">max_scaling</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_center_xy</span><span class="p">(</span><span class="n">image_hw</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span>
                    <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_scaling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_scaling</span><span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_scaling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling</span><span class="p">)</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.NonUniformScaling">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.NonUniformScaling">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">NonUniformScaling</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform non-uniform scaling (i.e. scaling factors in x- and y-dimensions are independent).&#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="n">min_scaling_xy</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">max_scaling_xy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform step.</span>
<span class="sd">                min_scaling_xy: Minimum scaling factors for x- and y-dimensions. If ``max_scaling_xy`` is not</span>
<span class="sd">                    set, these factors are always applied instead of selecting random factors from the range.</span>
<span class="sd">                max_scaling_xy: Maximum scaling factors for x- and y-dimensions.</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_scaling_xy</span> <span class="o">=</span> <span class="n">min_scaling_xy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling_xy</span> <span class="o">=</span> <span class="n">max_scaling_xy</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_center_xy</span><span class="p">(</span><span class="n">image_hw</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_scaling_xy</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_scaling_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">scale_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_scaling_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scaling_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span>
                    <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.Shearing">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.Shearing">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">Shearing</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Perform shearing.&#39;&#39;&#39;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="n">min_shearing_xy</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">max_shearing_xy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform step.</span>
<span class="sd">                min_shearing_xy: Minimum shearing parameters for x- and y-dimensions. If ``max_shearing_xy``</span>
<span class="sd">                    is not set, these parameters are always applied instead of selecting random parameters</span>
<span class="sd">                    from the range.</span>
<span class="sd">                max_shearing_xy: Maximum shearing parameters.</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_shearing_xy</span> <span class="o">=</span> <span class="n">min_shearing_xy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_shearing_xy</span> <span class="o">=</span> <span class="n">max_shearing_xy</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_center_xy</span><span class="p">(</span><span class="n">image_hw</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_shearing_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_shearing_xy</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shear_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_shearing_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_shearing_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">shear_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_shearing_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_shearing_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span>
                    <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">shear_x</span><span class="p">,</span> <span class="n">shear_y</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">transformation</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.Selection">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.Selection">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">Selection</span><span class="p">(</span><span class="n">TransformationStep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Probabilistically choose one sequence of steps out of multiple alternatives and perform the steps in this sequence.&#39;&#39;&#39;</span>

        <span class="n">__eps</span> <span class="o">=</span> <span class="mf">1e-6</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="n">option_probs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">options</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span>
                    <span class="n">List</span><span class="p">[</span><span class="n">AffineTransformer</span><span class="o">.</span><span class="n">TransformationStep</span><span class="p">],</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">AffineTransformer</span><span class="o">.</span><span class="n">TransformationStep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">TransformationStep</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">],</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">            Args:</span>
<span class="sd">                prob: Probability to perform this step.</span>
<span class="sd">                option_probs: Probabilities for the individual options. Has to sum up to 1 as one option is</span>
<span class="sd">                    always taken.</span>
<span class="sd">                options: The individual options. Each option is a sequence of transformation steps or a single</span>
<span class="sd">                    step.</span>

<span class="sd">            &#39;&#39;&#39;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

            <span class="n">num_options</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">option_probs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_options</span>
            <span class="p">),</span> <span class="s2">&quot;Number of per-option probabilities and options does not match&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">options</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_options</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">option_probs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_options</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">option_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eps</span>
            <span class="p">),</span> <span class="s2">&quot;Probabilities for options do not sum up to 1&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_size</span><span class="p">):</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_in_range</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="n">already_set</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prior_trafo</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">already_set</span> <span class="ow">and</span> <span class="n">draw</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options_accum_prob</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_option</span><span class="p">(</span><span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">already_set</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="n">res</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_apply_option</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prior_trafo</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">option_steps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">AffineTransformer</span><span class="o">.</span><span class="n">TransformationStep</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prior_trafo</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">option_steps</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
            <span class="n">per_option_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">:</span>
                <span class="n">option_types</span> <span class="o">=</span> <span class="n">prev_types</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
                    <span class="n">option_types</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="n">option_types</span><span class="p">)</span>
                <span class="n">per_option_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option_types</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">prev_types</span>
            <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="n">per_option_types</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ot</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AffineTransformer.ResizingMode">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.ResizingMode">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ResizingMode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Resizing mode types.</span>

<span class="sd">        The mode defines how the input viewport is adjusted to the output viewport when the output image shape has not the same aspect ratio as the input image shape.</span>

<span class="sd">        Note that as the image may be outside the input viewport due to affine transformations, it may e.g. happen that there is still image data in the padded region of the output viewport. In this case, the image will appear in the padded</span>
<span class="sd">        region and will not be replaced by the fill value.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#: Viewport is extended to preserve aspect ratio (i.e. if there are no other transformations,</span>
        <span class="c1">#: the output image will be padded).</span>
        <span class="n">STRETCH</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#: Viewport is stretched (i.e. image is non-uniformly scaled).</span>
        <span class="n">PAD</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">#: Viewport is cropped (i.e. if there are no other transformations, parts of the input image will be</span>
        <span class="c1">#: cropped away).</span>
        <span class="n">CROP</span> <span class="o">=</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="AffineTransformer.ResizingAnchor">
<a class="viewcode-back" href="../../../../contained_package_docs_mirror/dali_pipeline_framework/docs/api/processing_steps.html#accvlab.dali_pipeline_framework.processing_steps.AffineTransformer.ResizingAnchor">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ResizingAnchor</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Resizing mode anchor.</span>

<span class="sd">        The anchor defines which reference point in the output image is aligned to the corresponding point in</span>
<span class="sd">        the input image when adjusting the aspect ratio to match the output image using the PAD or CROP</span>
<span class="sd">        resizing mode.</span>

<span class="sd">        Important:</span>
<span class="sd">            Note that the anchor is only relevant when changing the aspect ratio of the image.</span>
<span class="sd">            The actual transformations such as scaling, rotation, etc. are not affected by the anchor,</span>
<span class="sd">            and always use the center of the image as reference point.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#: The center of the output image corresponds to the center of the input image</span>
        <span class="n">CENTER</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#: The top left corner of the output image corresponds to the top left corner of the input image.</span>
        <span class="c1">#: Depending on which direction is padded / cropped, this corresponds to either keeping the top or</span>
        <span class="c1">#: the left border aligned.</span>
        <span class="n">TOP_OR_LEFT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">#: The bottom right corner of the output image corresponds to the bottom left corner of the input</span>
        <span class="c1">#: image. Depending on which direction is padded / cropped, this corresponds to either keeping the</span>
        <span class="c1">#: bottom or the right border aligned.</span>
        <span class="n">BOTTOM_OR_RIGHT</span> <span class="o">=</span> <span class="mi">2</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_hw</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">resizing_mode</span><span class="p">:</span> <span class="n">AffineTransformer</span><span class="o">.</span><span class="n">ResizingMode</span><span class="p">,</span>
        <span class="n">resizing_anchor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AffineTransformer</span><span class="o">.</span><span class="n">ResizingAnchor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">image_field_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">image_hw_field_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">projection_matrix_field_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">point_field_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transformation_steps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">AffineTransformer</span><span class="o">.</span><span class="n">TransformationStep</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform_image_on_gpu</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            output_hw: Output resolution ``[height, width]``. The input image is resized to this size.</span>
<span class="sd">            resizing_mode: How to resolve aspect-ratio differences. See</span>
<span class="sd">                :class:`AffineTransformer.ResizingMode`.</span>
<span class="sd">            resizing_anchor: Anchor to use when ``resizing_mode`` is not ``STRETCH``. See</span>
<span class="sd">                :class:`AffineTransformer.ResizingAnchor`. Must be ``None`` when ``resizing_mode`` is</span>
<span class="sd">                ``STRETCH`` and set otherwise.</span>
<span class="sd">            image_field_names: Names of image fields to transform (see :class:`SampleDataGroup`). Set to</span>
<span class="sd">                ``None`` to not process images (e.g., only projection matrices or point sets). Cannot be</span>
<span class="sd">                set if ``image_hw_field_names`` is set.</span>
<span class="sd">            image_hw_field_names: Names of the fields containing image size ``[height, width]``. All listed</span>
<span class="sd">                fields must have identical values. If not, call this step separately per image (e.g., by</span>
<span class="sd">                name or by selecting a sub-tree, see :class:`GroupToApplyToSelectedStepBase`). Cannot be</span>
<span class="sd">                set if ``image_field_names`` is set. One of ``image_field_names`` or ``image_hw_field_names``</span>
<span class="sd">                must be provided (single source of truth for image size).</span>
<span class="sd">            projection_matrix_field_names: Names of fields with projection matrices that map to pixel</span>
<span class="sd">                coordinates. These matrices are updated to project correctly in the output image. Set to</span>
<span class="sd">                ``None`` to skip. If projection geometry is represented by extrinsics and intrinsics, only</span>
<span class="sd">                pass the intrinsics here; extrinsics are unaffected by an image-plane affine transform.</span>
<span class="sd">                Note that apart from true projection matrices, any matrices can be handled which transform</span>
<span class="sd">                points from a different coordinate system into the image coordinate system.</span>
<span class="sd">            point_field_names: Names of fields containing 2D point sets (e.g., landmarks). Points are</span>
<span class="sd">                transformed to remain consistent with the output images. Points are expected as rows; A row</span>
<span class="sd">                may contain multiple points, in which case consecutive pairs are treated as individual points</span>
<span class="sd">                and stored in the same format (e.g. ``[x1, y1, x2, y2]``).</span>
<span class="sd">            transformation_steps: Sequence of steps to perform. If ``None``,</span>
<span class="sd">                only resizing to the output resolution &amp; handling of changed aspect ratio is performed</span>
<span class="sd">                (no augmentation).</span>
<span class="sd">            transform_image_on_gpu: Whether to transform images on the GPU. Must be ``True`` if images are</span>
<span class="sd">                already on GPU. Default: ``True``.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Ensure exactly one of image_field_names or image_hw_field_names is set (single source of truth)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">image_field_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">image_hw_field_names</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either &#39;image_field_names&#39; or &#39;image_hw_field_names&#39; must be provided (but not both) to determine image size.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">image_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">image_hw_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only one of &#39;image_field_names&#39; or &#39;image_hw_field_names&#39; can be set (single source of truth for image size).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">image_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_field_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span> <span class="o">=</span> <span class="n">image_field_names</span>

        <span class="c1"># Flag to determine if we extract size from images or use size fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extract_size_from_images</span> <span class="o">=</span> <span class="n">image_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_hw_field_names</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">image_hw_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_hw_field_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_hw_field_names</span> <span class="o">=</span> <span class="n">image_hw_field_names</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection_matrix_field_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection_matrix_field_names</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">projection_matrix_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">projection_matrix_field_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span> <span class="o">=</span> <span class="n">projection_matrix_field_names</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_field_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_field_names</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">point_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_field_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span> <span class="o">=</span> <span class="n">point_field_names</span>

        <span class="k">if</span> <span class="n">transformation_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev_steps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">transformation_steps</span><span class="p">:</span>
                <span class="n">prev_steps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">check_prev_types_compatible_and_add_current_type</span><span class="p">(</span><span class="n">prev_steps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transformation_steps</span> <span class="o">=</span> <span class="n">transformation_steps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_output_hw</span> <span class="o">=</span> <span class="n">output_hw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_image_on_gpu</span> <span class="o">=</span> <span class="n">transform_image_on_gpu</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_resizing_mode</span> <span class="o">=</span> <span class="n">resizing_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resizing_anchor</span> <span class="o">=</span> <span class="n">resizing_anchor</span>
        <span class="k">if</span> <span class="n">resizing_mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">STRETCH</span> <span class="ow">and</span> <span class="n">resizing_anchor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When using STRETCH resizing mode, `resizing_anchor` has to be set to `None`.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resizing_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">STRETCH</span> <span class="ow">and</span> <span class="n">resizing_anchor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When not using STRETCH resizing mode, a `resizing_anchor` has to be selected.&quot;</span><span class="p">)</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
        <span class="nd">@do_not_convert</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">raise_exception_size_different</span><span class="p">(</span><span class="n">size_0</span><span class="p">,</span> <span class="n">size_1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Defined sizes of images do not match. Example unmatched sizes: </span><span class="si">{</span><span class="n">size_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">size_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">size_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">size_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">image_hw</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">is_image_hw_set</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_size_from_images</span><span class="p">:</span>
            <span class="c1"># Extract size from images using .shape</span>
            <span class="k">for</span> <span class="n">image_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span><span class="p">:</span>
                <span class="n">image_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start_index_paths</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_image_hw_set</span><span class="p">:</span>
                        <span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">image_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
                        <span class="c1"># Use fn.stack to create a proper tensor with [height, width]</span>
                        <span class="c1"># Cast to int32 for consistency with image_hw fields</span>
                        <span class="n">image_hw</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                            <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">image_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">image_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span>
                        <span class="p">)</span>
                        <span class="n">is_image_hw_set</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">start_index_paths</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">[</span><span class="n">start_index_paths</span><span class="p">:]:</span>
                        <span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
                        <span class="n">image_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
                        <span class="n">image_hw_i</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                            <span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">image_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">image_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">DALIDataType</span><span class="o">.</span><span class="n">INT32</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">image_hw_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">image_hw_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span><span class="n">image_hw</span><span class="p">,</span> <span class="n">image_hw_i</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">raise_exception_size_different</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use size fields</span>
            <span class="k">for</span> <span class="n">image_hw_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_hw_field_names</span><span class="p">:</span>
                <span class="n">image_hw_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_hw_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_hw_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start_index_paths</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_image_hw_set</span><span class="p">:</span>
                        <span class="n">image_hw</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">image_hw_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">is_image_hw_set</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">start_index_paths</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">image_hw_paths</span><span class="p">[</span><span class="n">start_index_paths</span><span class="p">:]:</span>
                        <span class="n">image_hw_i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_item_in_path</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">image_hw_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">image_hw_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span><span class="n">image_hw</span><span class="p">,</span> <span class="n">image_hw_i</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">raise_exception_size_different</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_transformation</span><span class="p">(</span>
            <span class="n">image_hw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformation_steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_hw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resizing_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resizing_anchor</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">image_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span><span class="p">:</span>
                <span class="n">image_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_field_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">image_field_name</span><span class="p">]</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine_transform_image</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">image_field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">projection_matrix_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span><span class="p">:</span>
                <span class="n">projection_matrix_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">projection_matrix_field_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pmp</span> <span class="ow">in</span> <span class="n">projection_matrix_paths</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">pmp</span><span class="p">)</span>
                    <span class="n">matrix</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">projection_matrix_field_name</span><span class="p">]</span>
                    <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_affine_post_transform_to_matrix</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">projection_matrix_field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span><span class="p">:</span>
                <span class="n">point_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">point_field_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">point_paths</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">point_field_name</span><span class="p">]</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine_transform_points</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">point_field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_size_from_images</span><span class="p">:</span>
            <span class="c1"># When using size fields, update them as specified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_hw_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">image_hw_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_hw_field_names</span><span class="p">:</span>
                    <span class="n">image_hw_paths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_hw_field_name</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">image_hw_paths</span><span class="p">:</span>
                        <span class="n">parent</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_parent_of_path</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
                        <span class="n">parent</span><span class="p">[</span><span class="n">image_hw_field_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_hw</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_and_adjust_data_format_input_to_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_empty</span><span class="p">:</span> <span class="n">SampleDataGroup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleDataGroup</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_size_from_images</span><span class="p">:</span>
            <span class="c1"># When extracting sizes from images, check that images exist</span>
            <span class="k">for</span> <span class="n">image_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span><span class="p">:</span>
                <span class="n">image_paths</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No occurrences of images with name `</span><span class="si">{</span><span class="n">image_name</span><span class="si">}</span><span class="s2">` found (the name / one of the names specified in the constructor).&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When using size fields, check that size fields exist</span>
            <span class="k">for</span> <span class="n">image_hw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_hw_field_names</span><span class="p">:</span>
                <span class="n">image_hw_paths</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_hw_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_hw_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No occurrences of image sizes with name &#39;</span><span class="si">{</span><span class="n">image_hw_name</span><span class="si">}</span><span class="s2">&#39; found (the name / one of the names specified in the constructor).&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Also check for image fields if they are to be transformed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">image_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_field_names</span><span class="p">:</span>
                    <span class="n">image_paths</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">image_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;No occurrences of images with name `</span><span class="si">{</span><span class="n">image_name</span><span class="si">}</span><span class="s2">` found (the name / one of the names specified in the constructor).&quot;</span>
                        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">projection_matrix_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projection_matrix_field_names</span><span class="p">:</span>
                <span class="n">projection_matrix_field_paths</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">projection_matrix_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">projection_matrix_field_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No occurrences of projection matrices with name `</span><span class="si">{</span><span class="n">projection_matrix_field_name</span><span class="si">}</span><span class="s2">` found (the name / one of the names specified in the constructor).&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point_field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_field_names</span><span class="p">:</span>
                <span class="n">point_field_paths</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">find_all_occurrences</span><span class="p">(</span><span class="n">point_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_field_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No occurrences of point sets with name `</span><span class="si">{</span><span class="n">point_field_name</span><span class="si">}</span><span class="s2">` found (the name / one of the names specified in the constructor).&quot;</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">data_empty</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">,</span> <span class="n">transformation_steps</span><span class="p">,</span> <span class="n">output_hw</span><span class="p">,</span> <span class="n">resizing_mode</span><span class="p">,</span> <span class="n">resizing_anchor</span><span class="p">):</span>
        <span class="n">image_resize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_transformation_to_output_size</span><span class="p">(</span>
            <span class="n">image_hw</span><span class="p">,</span> <span class="n">output_hw</span><span class="p">,</span> <span class="n">resizing_mode</span><span class="p">,</span> <span class="n">resizing_anchor</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">augmentation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_augmentation_transformation</span><span class="p">(</span><span class="n">image_hw</span><span class="p">,</span> <span class="n">transformation_steps</span><span class="p">)</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">augmentation</span><span class="p">,</span> <span class="n">image_resize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">image_resize</span>
        <span class="k">return</span> <span class="n">transformation</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_augmentation_transformation</span><span class="p">(</span><span class="n">image_hw</span><span class="p">,</span> <span class="n">transformation_steps</span><span class="p">):</span>
        <span class="n">transformation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transformation_steps</span><span class="p">:</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="n">image_hw</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Identity transform</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">transformation</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_transformation_to_output_size</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_hw</span><span class="p">,</span> <span class="n">output_hw</span><span class="p">,</span> <span class="n">resizing_mode</span><span class="p">,</span> <span class="n">resizing_anchor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">resizing_mode</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">STRETCH</span><span class="p">:</span>
            <span class="c1"># If stretching is used, scale both dimensions of the image to fit the output size</span>
            <span class="n">trafo_resolution</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">output_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">resizing_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">PAD</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">CROP</span><span class="p">]:</span>
            <span class="c1"># Otherwise, perform the following:</span>
            <span class="c1"># 1. Scaling to ensure input image to ensure that ...</span>
            <span class="k">if</span> <span class="n">resizing_mode</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">PAD</span><span class="p">:</span>
                <span class="c1"># ... scaled image completely fits inside ouput if padding is used</span>
                <span class="n">scale_output_input</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">output_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">resizing_mode</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingMode</span><span class="o">.</span><span class="n">CROP</span><span class="p">:</span>
                <span class="c1"># ... scaled image fills in the complete output image (and parts are cropped if needed) if cropping is used</span>
                <span class="n">scale_output_input</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">output_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Unknown resizing mode&quot;</span>
            <span class="n">scale_mat_resolution</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">scale_output_input</span><span class="p">,</span> <span class="n">scale_output_input</span><span class="p">))</span>

            <span class="c1"># 2. Position the image according to the anchor</span>
            <span class="k">if</span> <span class="n">resizing_anchor</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingAnchor</span><span class="o">.</span><span class="n">TOP_OR_LEFT</span><span class="p">:</span>
                <span class="c1"># No shift; represent as an affine translation transform with zero offset</span>
                <span class="n">shift_output_input_mat</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">resizing_anchor</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">ResizingAnchor</span><span class="o">.</span><span class="n">CENTER</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingAnchor</span><span class="o">.</span><span class="n">BOTTOM_OR_RIGHT</span><span class="p">]:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">resizing_anchor</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ResizingAnchor</span><span class="o">.</span><span class="n">CENTER</span> <span class="k">else</span> <span class="mf">1.0</span>
                <span class="n">point_orig_in_scaled_x</span> <span class="o">=</span> <span class="n">scale_output_input</span> <span class="o">*</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">point_orig_in_scaled_y</span> <span class="o">=</span> <span class="n">scale_output_input</span> <span class="o">*</span> <span class="n">input_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">point_scaled_x</span> <span class="o">=</span> <span class="n">output_hw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">point_scaled_y</span> <span class="o">=</span> <span class="n">output_hw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">shift_x</span> <span class="o">=</span> <span class="n">point_scaled_x</span> <span class="o">-</span> <span class="n">point_orig_in_scaled_x</span>
                <span class="n">shift_y</span> <span class="o">=</span> <span class="n">point_scaled_y</span> <span class="o">-</span> <span class="n">point_orig_in_scaled_y</span>
                <span class="n">shift_output_input_mat</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resizing anchor </span><span class="si">{</span><span class="n">resizing_anchor</span><span class="si">}</span><span class="s2"> not supported.&quot;</span><span class="p">)</span>

            <span class="c1"># 3. Get the final transformation as the scaling (1.) followed by centering (2.)</span>
            <span class="n">trafo_resolution</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">scale_mat_resolution</span><span class="p">,</span> <span class="n">shift_output_input_mat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resizing mode </span><span class="si">{</span><span class="n">resizing_mode</span><span class="si">}</span><span class="s2"> not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trafo_resolution</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_affine_transform_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_image_on_gpu</span><span class="p">:</span>
            <span class="n">transformed_image</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">warp_affine</span><span class="p">(</span>
                <span class="n">image</span><span class="o">.</span><span class="n">gpu</span><span class="p">(),</span>
                <span class="n">transform</span><span class="o">.</span><span class="n">gpu</span><span class="p">(),</span>
                <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_output_hw</span><span class="p">,</span>
                <span class="n">interp_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">INTERP_LINEAR</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">inverse_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformed_image</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">warp_affine</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span>
                <span class="n">transform</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_output_hw</span><span class="p">,</span>
                <span class="n">interp_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">INTERP_LINEAR</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">inverse_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">transformed_image</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_affine_post_transform_to_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">proj_mat</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
        <span class="n">last_row</span> <span class="o">=</span> <span class="n">get_as_data_node</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
        <span class="n">transform_to_use</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">last_row</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">proj_mat_out</span> <span class="o">=</span> <span class="n">apply_matrix</span><span class="p">(</span><span class="n">proj_mat</span><span class="p">,</span> <span class="n">transform_to_use</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proj_mat_out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_affine_transform_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">DataNode</span><span class="p">):</span>
        <span class="n">is_on_gpu</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="s2">&quot;gpu&quot;</span>
        <span class="k">if</span> <span class="n">is_on_gpu</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">gpu</span><span class="p">(),</span> <span class="n">transform</span><span class="o">.</span><span class="n">gpu</span><span class="p">(),</span> <span class="n">function</span><span class="o">=</span><span class="n">apply_transform_to_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">python_function</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">apply_transform_to_points</span><span class="p">)</span>

        <span class="c1"># Return resulting images, as well as the annotation (with modified bounding boxes) and the new image size</span>
        <span class="k">return</span> <span class="n">points</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, NVIDIA Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>