

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sample Code Documentation &mdash; ACCV-Lab 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=9282052d" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="PyTorch Integration Examples" href="pytorch_integration_examples/index.html" />
    <link rel="prev" title="API Reference" href="api.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ACCV-Lab
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">General Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../project_overview/README.html">ACCV-Lab Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides_index.html">Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contained Packages</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">On Demand Video Decoder</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataset_preparation.html">Dataset Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Sample Code Documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">1. Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sample-code-quick-reference">1.1 Sample Code Quick Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choosing-the-right-sample">1.2 Choosing the Right Sample</a></li>
<li class="toctree-l4"><a class="reference internal" href="#core-concepts">1.3 Core Concepts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quick-start">2. Quick Start</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running-your-first-sample">2.1 Running Your First Sample</a></li>
<li class="toctree-l4"><a class="reference internal" href="#understanding-the-basic-code-structure">2.2 Understanding the Basic Code Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#decoding-modes">3. Decoding Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#random-access-decoding">3.1 Random Access Decoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#use-cases">3.1.1 Use Cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-basic-random-access">3.1.2 Sample: Basic Random Access</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-random-access-with-fastinit">3.1.3 Sample: Random Access with FastInit</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#stream-access-decoding">3.2 Stream Access Decoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id1">3.2.1 Use Cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-stream-access">3.2.2 Sample: Stream Access</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-async-stream-access">3.2.3 Sample: Async Stream Access</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#separation-access-decoding">3.3 Separation Access Decoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id2">3.3.1 Use Cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="#two-stage-architecture">3.3.2 Two-Stage Architecture</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-basic-separation-access">3.3.3 Sample: Basic Separation Access</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-separation-access-with-getgoplist-api">3.3.4 Sample: Separation Access with GetGOPList API</a></li>
<li class="toctree-l5"><a class="reference internal" href="#gop-caching-feature">3.3.5 GOP Caching Feature</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#demuxer-free-decoding">3.4 Demuxer-Free Decoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id3">3.4.1 Use Cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-gop-file-storage-and-decoding">3.4.2 Sample: GOP File Storage and Decoding</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-gop-file-list-api">3.4.3 Sample: GOP File List API</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sample-batch-decode-from-multiple-demux-results">3.4.4 Sample: Batch Decode from Multiple Demux Results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pytorch_integration_examples/index.html">PyTorch Integration Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="evaluation.html">Evaluation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../batching_helpers/docs/index.html">Batching Helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dali_pipeline_framework/docs/index.html">DALI Pipeline Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../draw_heatmap/docs/index.html">Draw Heatmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../optim_test_tools/docs/index.html">Optimization Testing Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ACCV-Lab</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">On Demand Video Decoder</a></li>
      <li class="breadcrumb-item active">Sample Code Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/contained_package_docs_mirror/on_demand_video_decoder/docs/sample.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="sample-code-documentation">
<h1>Sample Code Documentation<a class="headerlink" href="#sample-code-documentation" title="Link to this heading"></a></h1>
<p>This document provides comprehensive guidance on using the sample codes in
<code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/</span></code>. The samples demonstrate various decoding modes and advanced
features of the <code class="docutils literal notranslate"><span class="pre">accvlab.on_demand_video_decoder</span></code> package.</p>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>The On-Demand Video Decoder package provides multiple decoding modes optimized for different use cases. This
section helps you quickly locate the sample code that matches your requirements.</p>
<section id="sample-code-quick-reference">
<h3>1.1 Sample Code Quick Reference<a class="headerlink" href="#sample-code-quick-reference" title="Link to this heading"></a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong></strong>The sample files mentioned in the tabled below are all located in the
<code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/</span></code> directory inside the ACCV-Lab repository.</p>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sample File</p></th>
<th class="head"><p>Use Case</p></th>
<th class="head"><p>Key APIs</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference download internal" download="" href="../../../_downloads/bc89507bec53dfd986c9deccb5bd61e8/SampleRandomAccess.py"><span class="xref download myst">SampleRandomAccess.py</span></a></p></td>
<td><p>Random frame sampling for training</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateGopDecoder" title="accvlab.on_demand_video_decoder.CreateGopDecoder"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateGopDecoder()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGB()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference download internal" download="" href="../../../_downloads/9fbed6117d8d1cb3783fdeb298abffde/SampleRandomAccessWithFastInit.py"><span class="xref download myst">SampleRandomAccessWithFastInit.py</span></a></p></td>
<td><p>Multi-clip batch processing with optimization</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.GetFastInitInfo" title="accvlab.on_demand_video_decoder.GetFastInitInfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetFastInitInfo()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference download internal" download="" href="../../../_downloads/f1ca4ec1a66939d69ed2a61e59e329fe/SampleStreamAccess.py"><span class="xref download myst">SampleStreamAccess.py</span></a></p></td>
<td><p>Sequential frame decoding</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateSampleReader" title="accvlab.on_demand_video_decoder.CreateSampleReader"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateSampleReader()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference download internal" download="" href="../../../_downloads/2f94dbdb4ecc1b4ced16248d5aa9644a/SampleSeparationAccess.py"><span class="xref download myst">SampleSeparationAccess.py</span></a></p></td>
<td><p>Demuxer/decoder separation with GOP caching</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPRGB()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit" title="accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isCacheHit()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference download internal" download="" href="../../../_downloads/b97ae65259c76b8f1eee84d7107448e0/SampleSeparationAccessGOPListAPI.py"><span class="xref download myst">SampleSeparationAccessGOPListAPI.py</span></a></p></td>
<td><p>Per-video GOP management with caching</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit" title="accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isCacheHit()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference download internal" download="" href="../../../_downloads/f5eef26376d41cb4166a3317f3b28259/SampleDecodeFromGopFiles.py"><span class="xref download myst">SampleDecodeFromGopFiles.py</span></a></p></td>
<td><p>GOP data persistence to disk</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.SavePacketsToFile" title="accvlab.on_demand_video_decoder.SavePacketsToFile"><code class="xref py py-func docutils literal notranslate"><span class="pre">SavePacketsToFile()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGops()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference download internal" download="" href="../../../_downloads/319554506d0d6a6af5e3c17f0306d5a0/SampleDecodeFromGopFilesToListAPI.py"><span class="xref download myst">SampleDecodeFromGopFilesToListAPI.py</span></a></p></td>
<td><p>Selective GOP loading</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGopsToList()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference download internal" download="" href="../../../_downloads/7dc59b5a852b80314a4f51d6ee06b2e8/SampleDecodeFromGopList.py"><span class="xref download myst">SampleDecodeFromGopList.py</span></a></p></td>
<td><p>Batch decode from multiple demux results (N demux → 1 decode)</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference download internal" download="" href="../../../_downloads/f3fdc89d3370f5ba5a18eac0d3ee3683/SampleStreamAsyncAccess.py"><span class="xref download myst">SampleStreamAsyncAccess.py</span></a></p></td>
<td><p>Async stream decoding with prefetching</p></td>
<td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateSampleReader" title="accvlab.on_demand_video_decoder.CreateSampleReader"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateSampleReader()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsync" title="accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsync()</span></code></a>, <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsyncGetBuffer" title="accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsyncGetBuffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsyncGetBuffer()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>For details on the <strong>Key APIs</strong>, please refer to the API documentation of the corresponding functions and classes.</p>
</section>
<section id="choosing-the-right-sample">
<h3>1.2 Choosing the Right Sample<a class="headerlink" href="#choosing-the-right-sample" title="Link to this heading"></a></h3>
<p>Use this decision tree to select the appropriate sample for your use case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Decoding Mode Selection:

If you need random frame access:
    If the input video resolution, color information, and other parameters remain unchanged:
        → Use SampleRandomAccessWithFastInit
    Otherwise:
        → Use SampleRandomAccess

If you need sequential frame decoding:
    If you need async decoding with prefetching for lower latency:
        → Use SampleStreamAsyncAccess
    Otherwise:
        → Use SampleStreamAccess

If you need to separate demuxing and decoding:
    If per-video GOP management is required (i.e., use of separate per-video GOP data):
        → Use SampleSeparationAccessGOPListAPI
    Otherwise:
        → Use SampleSeparationAccess

If you need to save GOP data to disk:
    → Use SampleDecodeFromGopFiles

If you need to batch decode from multiple separate demux operations:
    (e.g., DataLoader workers demux in parallel, main process batch decode)
    → Use SampleDecodeFromGopList
</pre></div>
</div>
</section>
<section id="core-concepts">
<h3>1.3 Core Concepts<a class="headerlink" href="#core-concepts" title="Link to this heading"></a></h3>
<p>Before diving into the samples, understanding these concepts will be helpful:</p>
<ul class="simple">
<li><p><strong>GOP (Group of Pictures)</strong>: A sequence of video frames starting with a keyframe (I-frame). GOP structure is essential for video compression and random access.</p></li>
<li><p><strong>Decoding Modes</strong>: <code class="docutils literal notranslate"><span class="pre">accvlab.on_demand_video_decoder</span></code> supports four primary modes:</p>
<ul>
<li><p><strong>Random Access</strong>: Direct access to any frame without sequential decoding</p></li>
<li><p><strong>Stream Access</strong>: Optimized for sequential frame processing with caching</p></li>
<li><p><strong>Separation Access</strong>: Separate demuxing and decoding stages</p></li>
<li><p><strong>Demuxer-Free</strong>: Decode directly from pre-extracted GOP data</p></li>
</ul>
</li>
<li><p><strong>FastInit</strong>: An optimization technique that caches stream metadata to accelerate decoder initialization for multiple clips with similar properties.</p></li>
<li><p><strong>GOP Caching</strong>: A Python-side caching mechanism that stores extracted GOP data in memory. When the same video file is requested with a <code class="docutils literal notranslate"><span class="pre">frame_id</span></code> that falls within an already cached GOP range, the cached data is returned directly without re-demuxing from the video file.</p></li>
</ul>
</section>
</section>
<section id="quick-start">
<h2>2. Quick Start<a class="headerlink" href="#quick-start" title="Link to this heading"></a></h2>
<p>This section walks you through running your first sample in 5 minutes.</p>
<section id="running-your-first-sample">
<h3>2.1 Running Your First Sample<a class="headerlink" href="#running-your-first-sample" title="Link to this heading"></a></h3>
<p>The simplest example is <a class="reference download internal" download="" href="../../../_downloads/bc89507bec53dfd986c9deccb5bd61e8/SampleRandomAccess.py"><span class="xref download myst">SampleRandomAccess.py</span></a>. Here’s how to run it:</p>
<p><strong>Step 1: Prepare video files</strong></p>
<p>Edit the file paths in the sample code (also see the <a class="reference internal" href="dataset_preparation.html"><span class="std std-doc">Dataset Preparation</span></a> section):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/path/to/your/video1.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/path/to/your/video2.mp4&quot;</span><span class="p">,</span>
    <span class="c1"># Add more video paths as needed</span>
<span class="p">]</span>
</pre></div>
</div>
<p><strong>Step 2: Run the sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleRandomAccess.py
</pre></div>
</div>
<p><strong>Step 3: Verify the output</strong></p>
<p>Expected output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>NVIDIA accvlab.on_demand_video_decoder - Random Access Video Decoding Sample
================================================================

Initializing NVIDIA GPU video decoder...
Decoder initialized successfully on GPU 0 with support for 6 concurrent files
Processing 6 video files from multi-camera setup

--- Iteration 1/5 ---
Target frame indices: [45, 23, 78, 12, 56, 89]
Initiating GPU decoding...
Successfully decoded 6 frames
Converting frames to PyTorch tensors...
Tensor shape: torch.Size([1, 900, 1600, 3])
Tensor dtype: torch.uint8
</pre></div>
</div>
</section>
<section id="understanding-the-basic-code-structure">
<h3>2.2 Understanding the Basic Code Structure<a class="headerlink" href="#understanding-the-basic-code-structure" title="Link to this heading"></a></h3>
<p>All samples follow a similar structure:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">accvlab.on_demand_video_decoder</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nvc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># 1. Initialize decoder</span>
<span class="n">decoder</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span>
    <span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>  <span class="c1"># Maximum concurrent files</span>
    <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span>       <span class="c1"># GPU device ID</span>
<span class="p">)</span>

<span class="c1"># 2. Specify video files and frame IDs</span>
<span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;/path/to/video1.mp4&quot;</span><span class="p">,</span> <span class="s2">&quot;/path/to/video2.mp4&quot;</span><span class="p">]</span>
<span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>  <span class="c1"># Frame ID for each video</span>

<span class="c1"># 3. Decode frames</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">DecodeN12ToRGB</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span> 
    <span class="n">frame_id_list</span><span class="p">,</span> 
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Output BGR format</span>
<span class="p">)</span>

<span class="c1"># 4. Convert to PyTorch tensors (optional)</span>
<span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">decoded_frames</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="decoding-modes">
<h2>3. Decoding Modes<a class="headerlink" href="#decoding-modes" title="Link to this heading"></a></h2>
<p>This section provides detailed documentation for each decoding mode with corresponding sample codes.</p>
<section id="random-access-decoding">
<h3>3.1 Random Access Decoding<a class="headerlink" href="#random-access-decoding" title="Link to this heading"></a></h3>
<p>Random Access mode allows direct access to any frame in a video without sequential decoding. The decoder automatically finds the GOP containing the target frame and decodes from the nearest keyframe.</p>
<section id="use-cases">
<h4>3.1.1 Use Cases<a class="headerlink" href="#use-cases" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Training with random frame sampling</p></li>
<li><p>Processing single video clips</p></li>
<li><p>Random switching between different videos</p></li>
<li><p>Non-sequential frame access patterns</p></li>
</ul>
</section>
<section id="sample-basic-random-access">
<h4>3.1.2 Sample: Basic Random Access<a class="headerlink" href="#sample-basic-random-access" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleRandomAccess.py</span></code></p>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateGopDecoder" title="accvlab.on_demand_video_decoder.CreateGopDecoder"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateGopDecoder()</span></code></a>: Initialize the GOP decoder</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGB()</span></code></a>: Decode frames to RGB/BGR format</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize the decoder:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">accvlab.on_demand_video_decoder</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nvc</span>

<span class="n">nv_gop_dec</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span>
    <span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>  <span class="c1"># Maximum number of concurrent files</span>
    <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span>       <span class="c1"># Target GPU device ID</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Prepare video files and frame indices:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Multi-camera setup from nuScenes dataset (example for sequence named `n008-2018-08-30-15-16-55-0400`)</span>
<span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_BACK_RIGHT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_FRONT_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_FRONT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/nuscenes/video_samples/n008-2018-08-30-15-16-55-0400/CAM_FRONT_RIGHT.mp4&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># Random frame indices (one per video)</span>
<span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">))]</span>
</pre></div>
</div>
<p>Decode frames:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGB</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>  <span class="c1"># List of video file paths</span>
    <span class="n">frame_id_list</span><span class="p">,</span>   <span class="c1"># List of target frame indices</span>
    <span class="kc">True</span>             <span class="c1"># Output in BGR format (OpenCV compatible)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Convert to PyTorch tensors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="n">tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> 
               <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">decoded_frames</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Performance Characteristics</strong></p>
<ul class="simple">
<li><p>Memory usage: Scales with concurrent file count and video resolution</p></li>
<li><p>GPU utilization: 70-90% depending on video codec complexity</p></li>
<li><p>Throughput: Approximately 500-1500 FPS on modern GPUs (e.g., A100)</p></li>
</ul>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleRandomAccess.py
</pre></div>
</div>
<p>Note: Modify the <code class="docutils literal notranslate"><span class="pre">file_path_list</span></code> in the code to point to your video files.</p>
</section>
<section id="sample-random-access-with-fastinit">
<h4>3.1.3 Sample: Random Access with FastInit<a class="headerlink" href="#sample-random-access-with-fastinit" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleRandomAccessWithFastInit.py</span></code></p>
<p><strong>When to Use</strong></p>
<p>FastInit optimization is beneficial when:</p>
<ul class="simple">
<li><p>Processing multiple video clips from the same dataset</p></li>
<li><p>All clips have similar properties (resolution, codec, GOP size)</p></li>
<li><p>Initialization latency is a bottleneck</p></li>
<li><p>Batch processing scenarios</p></li>
</ul>
<p><strong>Performance Improvement</strong></p>
<p>FastInit can reduce decoder initialization time by 40-70% for subsequent clips after the first one.</p>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.GetFastInitInfo" title="accvlab.on_demand_video_decoder.GetFastInitInfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetFastInitInfo()</span></code></a>: Extract stream metadata for fast initialization</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGB()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">fastStreamInfos</span></code> parameter</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize decoder (one-time setup):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nv_gop_dec</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Get fast initialization info from sample files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract metadata from first clip</span>
<span class="n">sample_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="n">fast_stream_infos</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">GetFastInitInfo</span><span class="p">(</span><span class="n">sample_files</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong></strong><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.GetFastInitInfo" title="accvlab.on_demand_video_decoder.GetFastInitInfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetFastInitInfo()</span></code></a> only needs to be called once for
clips with similar properties.</p>
</div>
<p>Warmup (skip first-time hardware initialization overhead):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGB</span><span class="p">(</span>
    <span class="n">sample_files</span><span class="p">,</span> 
    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_files</span><span class="p">),</span> 
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">fastStreamInfos</span><span class="o">=</span><span class="n">fast_stream_infos</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Process multiple clips with FastInit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">clip_path</span> <span class="ow">in</span> <span class="n">clip_paths</span><span class="p">:</span>
    <span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clip_path</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">clip_path</span><span class="p">)]</span>
    <span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">))]</span>
    
    <span class="c1"># Use fastStreamInfos for optimized initialization</span>
    <span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGB</span><span class="p">(</span>
        <span class="n">file_path_list</span><span class="p">,</span>
        <span class="n">frame_id_list</span><span class="p">,</span>
        <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fastStreamInfos</span><span class="o">=</span><span class="n">fast_stream_infos</span>  <span class="c1"># Reuse cached stream info</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleRandomAccessWithFastInit.py
</pre></div>
</div>
</section>
</section>
<section id="stream-access-decoding">
<h3>3.2 Stream Access Decoding<a class="headerlink" href="#stream-access-decoding" title="Link to this heading"></a></h3>
<p>Stream Access mode is optimized for sequential frame processing with intelligent caching. It is particularly useful for temporal models and sequential video analysis.</p>
<section id="id1">
<h4>3.2.1 Use Cases<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Sequential frame decoding from videos</p></li>
<li><p>Temporal models (e.g., StreamPETR, BEVFormer)</p></li>
<li><p>Time-series video analysis</p></li>
<li><p>Scenarios where frames are accessed in order</p></li>
</ul>
</section>
<section id="sample-stream-access">
<h4>3.2.2 Sample: Stream Access<a class="headerlink" href="#sample-stream-access" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleStreamAccess.py</span></code></p>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateSampleReader" title="accvlab.on_demand_video_decoder.CreateSampleReader"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateSampleReader()</span></code></a>: Initialize the sample reader (different from
<a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateGopDecoder" title="accvlab.on_demand_video_decoder.CreateGopDecoder"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateGopDecoder()</span></code></a>)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeN12ToRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGB()</span></code></a>: Decode frames with caching
optimization</p></li>
</ul>
<p><strong>Key Difference from Random Access</strong></p>
<p>Stream Access uses <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateSampleReader" title="accvlab.on_demand_video_decoder.CreateSampleReader"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateSampleReader()</span></code></a> instead of
<a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateGopDecoder" title="accvlab.on_demand_video_decoder.CreateGopDecoder"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateGopDecoder()</span></code></a>. The key advantage is the use of
caching-based optimizations. There is also the ability to iterate over individual sets of video file sets,
each set being accessed sequentially (with the number of sets being controlled by the <code class="docutils literal notranslate"><span class="pre">num_of_set</span></code> parameter).</p>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize the sample reader:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nv_gop_dec</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateSampleReader</span><span class="p">(</span>
    <span class="n">num_of_set</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>              <span class="c1"># Cache for this many video sets</span>
    <span class="n">num_of_file</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>             <span class="c1"># Maximum number of files per set</span>
    <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Understanding num_of_set</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">num_of_set</span></code> parameter controls caching behavior:</p>
<ul class="simple">
<li><p>Set to 1 for simple sequential access</p></li>
<li><p>Set to <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> for StreamPETR-like access patterns (iterating over the samples inside a batch,
accessing the same video files in every <code class="docutils literal notranslate"><span class="pre">batch_size</span></code>-th call to the decoder)</p></li>
</ul>
<p>Example: If <code class="docutils literal notranslate"><span class="pre">batch_size==4</span></code>, set <code class="docutils literal notranslate"><span class="pre">num_of_set=4</span></code> to cache 4 different video clips.</p>
<p>Process frames sequentially:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/scene_CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/scene_CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="c1"># ... more files</span>
<span class="p">]</span>

<span class="c1"># Start from frame 0</span>
<span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="c1"># Increment frame indices (sequential access)</span>
    <span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">fid</span> <span class="o">+</span> <span class="mi">7</span> <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">frame_id_list</span><span class="p">]</span>
    
    <span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGB</span><span class="p">(</span>
        <span class="n">file_path_list</span><span class="p">,</span>
        <span class="n">frame_id_list</span><span class="p">,</span>
        <span class="kc">True</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><strong>Caching Behavior</strong></p>
<p>Stream Access mode caches:</p>
<ul class="simple">
<li><p>Demuxer state</p></li>
<li><p>Decoder state</p></li>
<li><p>Recently accessed GOPs</p></li>
</ul>
<p>This reduces overhead for sequential access patterns compared to Random Access mode.</p>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleStreamAccess.py
</pre></div>
</div>
</section>
<section id="sample-async-stream-access">
<h4>3.2.3 Sample: Async Stream Access<a class="headerlink" href="#sample-async-stream-access" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleStreamAsyncAccess.py</span></code></p>
<p><strong>When to Use</strong></p>
<p>Async Stream Access is beneficial when:</p>
<ul class="simple">
<li><p>Lower latency is required for streaming applications</p></li>
<li><p>Prefetching next frame while processing current frame improves latency</p></li>
<li><p>Labeling task model need high-performance inference</p></li>
<li><p>GPU utilization needs to be maximized through overlapped operations</p></li>
</ul>
<p><strong>Key Advantages Over Basic Stream Access</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>Stream Access</p></th>
<th class="head"><p>Async Stream Access</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Decode mode</p></td>
<td><p>Synchronous</p></td>
<td><p>Asynchronous with prefetching</p></td>
</tr>
<tr class="row-odd"><td><p>Latency</p></td>
<td><p>Standard</p></td>
<td><p>Lower (prefetched frames ready)</p></td>
</tr>
<tr class="row-even"><td><p>GPU utilization</p></td>
<td><p>Standard</p></td>
<td><p>Better (decode/process overlap)</p></td>
</tr>
</tbody>
</table>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CreateSampleReader" title="accvlab.on_demand_video_decoder.CreateSampleReader"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateSampleReader()</span></code></a>: Initialize the sample reader</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsync" title="accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsync()</span></code></a>: Start asynchronous decoding</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsyncGetBuffer" title="accvlab.on_demand_video_decoder.PyNvSampleReader.DecodeN12ToRGBAsyncGetBuffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsyncGetBuffer()</span></code></a>: Retrieve decoded frames from buffer</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize the sample reader:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">accvlab.on_demand_video_decoder</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nvc</span>

<span class="n">nv_stream_dec</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateSampleReader</span><span class="p">(</span>
    <span class="n">num_of_set</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>              <span class="c1"># Cache for this many video sets</span>
    <span class="n">num_of_file</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>             <span class="c1"># Maximum number of files per set</span>
    <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span>                     <span class="c1"># Target GPU device ID</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Async Decoding Pattern</strong></p>
<p>The async pattern consists of two main operations:</p>
<ol class="arabic simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsync</span></code></strong>: Start asynchronous decoding (non-blocking)</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsyncGetBuffer</span></code></strong>: Get decoded frames (waits if not ready)</p></li>
</ol>
<p>First iteration - start async decode and get result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start async decode</span>
<span class="n">nv_stream_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGBAsync</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>
    <span class="n">frame_id_list</span><span class="p">,</span>
    <span class="kc">False</span><span class="p">,</span>  <span class="c1"># Output in RGB format (False=RGB, True=BGR)</span>
<span class="p">)</span>

<span class="c1"># Get the result (will wait for async decode to complete)</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_stream_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGBAsyncGetBuffer</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>
    <span class="n">frame_id_list</span><span class="p">,</span>
    <span class="kc">False</span><span class="p">,</span>  <span class="c1"># Output in RGB format</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Subsequent iterations - get prefetched result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get prefetched result from buffer (already decoded in background)</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_stream_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGBAsyncGetBuffer</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>
    <span class="n">frame_id_list</span><span class="p">,</span>
    <span class="kc">False</span><span class="p">,</span>  <span class="c1"># Output in RGB format</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Prefetching Pattern</strong></p>
<p>The key optimization is prefetching the next frame while processing the current one:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Process current frame</span>
<span class="n">tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">decoded_frames</span><span class="p">]</span>
<span class="n">rgb_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Prefetch next frame (non-blocking, happens in background)</span>
<span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames_to_decode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">next_frame</span> <span class="o">=</span> <span class="n">frames_to_decode</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">next_frame_id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_frame</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">)</span>
    <span class="n">nv_stream_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGBAsync</span><span class="p">(</span>
        <span class="n">file_path_list</span><span class="p">,</span>
        <span class="n">next_frame_id_list</span><span class="p">,</span>
        <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c1"># Continue processing current frame...</span>
<span class="c1"># Next iteration will get prefetched frame immediately</span>
</pre></div>
</div>
<p><strong>Important: Zero-Copy Frame Management</strong></p>
<blockquote>
<div><p><strong>⚠️ Warning</strong>: The decoded frames returned by <code class="docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsyncGetBuffer</span></code> are zero-copy
references to internal buffers. You <strong>must</strong> deep copy the frames before calling
<code class="docutils literal notranslate"><span class="pre">DecodeN12ToRGBAsync</span></code> again, otherwise the data will be overwritten.</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CORRECT: Deep copy frames before next async call</span>
<span class="n">tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">decoded_frames</span><span class="p">]</span>
<span class="c1"># or</span>
<span class="n">rgb_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">decoded_frames</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now safe to call DecodeN12ToRGBAsync for next frame</span>
<span class="n">nv_stream_dec</span><span class="o">.</span><span class="n">DecodeN12ToRGBAsync</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Complete Async Workflow</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Iteration 1:
  DecodeN12ToRGBAsync(frame_0)     → Start decode
  DecodeN12ToRGBAsyncGetBuffer()   → Wait &amp; get frame_0
  Process frame_0
  DecodeN12ToRGBAsync(frame_1)     → Prefetch frame_1

Iteration 2:
  DecodeN12ToRGBAsyncGetBuffer()   → Get prefetched frame_1 (fast!)
  Process frame_1
  DecodeN12ToRGBAsync(frame_2)     → Prefetch frame_2

Iteration N:
  DecodeN12ToRGBAsyncGetBuffer()   → Get prefetched frame_N
  Process frame_N
  (No prefetch for last frame)
</pre></div>
</div>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleStreamAsyncAccess.py
</pre></div>
</div>
</section>
</section>
<section id="separation-access-decoding">
<h3>3.3 Separation Access Decoding<a class="headerlink" href="#separation-access-decoding" title="Link to this heading"></a></h3>
<p>Separation Access mode decouples demuxing and decoding into two separate stages. This provides fine-grained control over the video processing pipeline and enables advanced optimization strategies.</p>
<section id="id2">
<h4>3.3.1 Use Cases<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Need separate control over demuxing and decoding</p></li>
<li><p>One-time demuxing, multiple decoding operations</p></li>
<li><p>Inspection or processing of intermediate packet data</p></li>
<li><p>Custom processing pipelines</p></li>
</ul>
</section>
<section id="two-stage-architecture">
<h4>3.3.2 Two-Stage Architecture<a class="headerlink" href="#two-stage-architecture" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stage 1 (Demuxing):
Video File → GetGOP() → Packet Data (GOP)
                         ├─ packets
                         ├─ first_frame_ids
                         └─ gop_lens

Stage 2 (Decoding):
Packet Data → DecodeFromGOPRGB() → Decoded Frames
</pre></div>
</div>
</section>
<section id="sample-basic-separation-access">
<h4>3.3.3 Sample: Basic Separation Access<a class="headerlink" href="#sample-basic-separation-access" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleSeparationAccess.py</span></code></p>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a>: Extract packet data (demuxing only)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPRGB()</span></code></a>: Decode from packet data
(decoding only)</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize two separate decoders:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Stage 1 decoder: for packet extraction</span>
<span class="n">nv_gop_dec1</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Stage 2 decoder: for packet decoding</span>
<span class="n">nv_gop_dec2</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong></strong>Using separate decoder instances allows independent configuration and resource management.</p>
</div>
<p>Stage 1 - Extract packet data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/scene_CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/scene_CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="c1"># ... more files</span>
<span class="p">]</span>

<span class="c1"># Extract GOP data containing frame 77 for all videos</span>
<span class="n">packets</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">nv_gop_dec1</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>
    <span class="p">[</span><span class="mi">77</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Understanding the return values:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">packets</span></code>: Compressed packet data (numpy array)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first_frame_ids</span></code>: First frame ID in each extracted GOP</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gop_lens</span></code>: Number of frames in each GOP</p></li>
</ul>
<p>Stage 2 - Decode from packet data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate frame IDs within the GOP range</span>
<span class="n">frame_id_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">first_frame_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">first_frame_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gop_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">))</span>
<span class="p">]</span>

<span class="c1"># Decode frames directly from packet data</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPRGB</span><span class="p">(</span>
    <span class="n">packets</span><span class="p">,</span>           <span class="c1"># Packet data from Stage 1</span>
    <span class="n">file_path_list</span><span class="p">,</span>    <span class="c1"># Original file paths (for reference)</span>
    <span class="n">frame_id_list</span><span class="p">,</span>     <span class="c1"># Target frame indices</span>
    <span class="kc">True</span>               <span class="c1"># BGR output</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Validation</strong></p>
<p>Always validate that frame IDs are within GOP range:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">frame_id</span> <span class="o">&lt;</span> <span class="n">first_frame_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">frame_id</span> <span class="o">&gt;=</span> <span class="n">first_frame_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gop_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Frame </span><span class="si">{</span><span class="n">frame_id</span><span class="si">}</span><span class="s2"> is out of range for GOP starting at </span><span class="si">{</span><span class="n">first_frame_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Advantages of Separation</strong></p>
<ol class="arabic simple">
<li><p>Demux once, decode multiple times with different frame selections</p></li>
<li><p>Ability to inspect or process packet data</p></li>
<li><p>Separate optimization of demuxing and decoding stages</p></li>
<li><p>Foundation for more advanced processing pipelines</p></li>
</ol>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleSeparationAccess.py
</pre></div>
</div>
</section>
<section id="sample-separation-access-with-getgoplist-api">
<h4>3.3.4 Sample: Separation Access with GetGOPList API<a class="headerlink" href="#sample-separation-access-with-getgoplist-api" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleSeparationAccessGOPListAPI.py</span></code></p>
<p><strong>When to Use</strong></p>
<p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a> is preferred over
<a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> when:</p>
<ul class="simple">
<li><p>Processing large video collections</p></li>
<li><p>Per-video cache management is needed</p></li>
<li><p>Selective video loading is required</p></li>
<li><p>Distributed storage and processing</p></li>
</ul>
<p><strong>Core Difference: <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> vs</strong>
<strong><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a></strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a></p></th>
<th class="head"><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return type</p></td>
<td><p>Single merged bundle</p></td>
<td><p>List of per-video bundles</p></td>
</tr>
<tr class="row-odd"><td><p>Data structure</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(packets,</span> <span class="pre">ids,</span> <span class="pre">lens)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[(packets1,</span> <span class="pre">ids1,</span> <span class="pre">lens1),</span> <span class="pre">(packets2,</span> <span class="pre">ids2,</span> <span class="pre">lens2),</span> <span class="pre">...]</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Memory management</p></td>
<td><p>Load all or nothing</p></td>
<td><p>Load selectively</p></td>
</tr>
<tr class="row-odd"><td><p>Decoding API</p></td>
<td><p>DecodeFromGOPRGB</p></td>
<td><p>DecodeFromGOPListRGB</p></td>
</tr>
<tr class="row-even"><td><p>Best for</p></td>
<td><p>Batch processing all videos</p></td>
<td><p>Per-video management</p></td>
</tr>
</tbody>
</table>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a>: Extract packet data per video (not
merged)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a>: Decode from list of packet
data</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Stage 1 - Extract per-video GOP data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_path_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_RIGHT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT_RIGHT.mp4&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># Extract GOP data, returns list of tuples</span>
<span class="n">gop_list</span> <span class="o">=</span> <span class="n">nv_gop_dec1</span><span class="o">.</span><span class="n">GetGOPList</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span>
    <span class="p">[</span><span class="mi">77</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># gop_list structure:</span>
<span class="c1"># [</span>
<span class="c1">#   (packets_video1, first_frame_ids_video1, gop_lens_video1),</span>
<span class="c1">#   (packets_video2, first_frame_ids_video2, gop_lens_video2),</span>
<span class="c1">#   ...</span>
<span class="c1"># ]</span>
</pre></div>
</div>
<p>Per-video GOP data inspection:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">gop_data</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gop_list</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Video </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  GOP data size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gop_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  First frame ID: </span><span class="si">{</span><span class="n">first_frame_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  GOP length: </span><span class="si">{</span><span class="n">gop_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Simulating per-video caching:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Cache GOP data per video</span>
<span class="n">gop_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">gop_data</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gop_list</span><span class="p">):</span>
    <span class="n">cache_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;video_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_frame_77&quot;</span>
    <span class="n">gop_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;gop_data&#39;</span><span class="p">:</span> <span class="n">gop_data</span><span class="p">,</span>
        <span class="s1">&#39;first_frame_ids&#39;</span><span class="p">:</span> <span class="n">first_frame_ids</span><span class="p">,</span>
        <span class="s1">&#39;gop_lens&#39;</span><span class="p">:</span> <span class="n">gop_lens</span><span class="p">,</span>
        <span class="s1">&#39;filepath&#39;</span><span class="p">:</span> <span class="n">file_path_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Stage 2 - Selective decoding:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select only specific videos to decode (e.g., front cameras only)</span>
<span class="n">selected_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="c1"># Front-left, front, front-right</span>

<span class="n">selected_gop_data_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">selected_filepaths</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">selected_frame_ids</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">:</span>
    <span class="n">cache_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;video_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">_frame_77&quot;</span>
    <span class="n">cached_item</span> <span class="o">=</span> <span class="n">gop_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
    
    <span class="c1"># Generate random frame within GOP range</span>
    <span class="n">first_frame_id</span> <span class="o">=</span> <span class="n">cached_item</span><span class="p">[</span><span class="s1">&#39;first_frame_ids&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gop_len</span> <span class="o">=</span> <span class="n">cached_item</span><span class="p">[</span><span class="s1">&#39;gop_lens&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">random_frame</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">first_frame_id</span><span class="p">,</span> <span class="n">first_frame_id</span> <span class="o">+</span> <span class="n">gop_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">selected_gop_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cached_item</span><span class="p">[</span><span class="s1">&#39;gop_data&#39;</span><span class="p">])</span>
    <span class="n">selected_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cached_item</span><span class="p">[</span><span class="s1">&#39;filepath&#39;</span><span class="p">])</span>
    <span class="n">selected_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_frame</span><span class="p">)</span>

<span class="c1"># Decode only selected videos</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPListRGB</span><span class="p">(</span>
    <span class="n">selected_gop_data_list</span><span class="p">,</span>  <span class="c1"># List of GOP data for selected videos</span>
    <span class="n">selected_filepaths</span><span class="p">,</span>      <span class="c1"># Corresponding file paths</span>
    <span class="n">selected_frame_ids</span><span class="p">,</span>      <span class="c1"># Frame IDs to decode</span>
    <span class="kc">True</span>                     <span class="c1"># BGR output</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Key Advantages</strong></p>
<ol class="arabic simple">
<li><p>Load only required videos from cache (memory efficient)</p></li>
<li><p>Per-video cache management (independent expiration, priority)</p></li>
<li><p>Better suited for distributed systems</p></li>
<li><p>Reduced inter-video dependencies</p></li>
</ol>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleSeparationAccessGOPListAPI.py
</pre></div>
</div>
</section>
<section id="gop-caching-feature">
<h4>3.3.5 GOP Caching Feature<a class="headerlink" href="#gop-caching-feature" title="Link to this heading"></a></h4>
<p>The GOP caching feature automatically stores extracted GOP data in Python memory, eliminating the need for
manual cache management by the user. When enabled, subsequent calls to <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> or <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a> with the same
video file and a <code class="docutils literal notranslate"><span class="pre">frame_id</span></code> within the cached GOP range will return cached data without re-demuxing.</p>
<p><strong>Why Use GOP Caching?</strong></p>
<p>In training scenarios, especially with video datasets:</p>
<ul class="simple">
<li><p>The same video file may be accessed multiple times with different frame indices</p></li>
<li><p>Multiple frame indices often fall within the same GOP (Group of Pictures)</p></li>
<li><p>Re-demuxing for each access wastes I/O and CPU resources</p></li>
</ul>
<p>Without caching, users would need to manually track GOP ranges and manage cache dictionaries. With the
<code class="docutils literal notranslate"><span class="pre">useGOPCache</span></code> parameter, this is handled automatically.</p>
<p><strong>Enabling GOP Caching</strong></p>
<p>Set <code class="docutils literal notranslate"><span class="pre">useGOPCache=True</span></code> when calling <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> or <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">accvlab.on_demand_video_decoder</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nvc</span>

<span class="n">decoder</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># First call - fetches GOP data from video files</span>
<span class="n">packets</span><span class="p">,</span> <span class="n">first_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span> 
    <span class="p">[</span><span class="mi">77</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">),</span> 
    <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Second call with frame_id=80 (within the same GOP range) - returns from cache</span>
<span class="n">packets</span><span class="p">,</span> <span class="n">first_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
    <span class="n">file_path_list</span><span class="p">,</span> 
    <span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">),</span> 
    <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Cache Hit Condition</strong></p>
<p>A cache hit occurs when:</p>
<ul class="simple">
<li><p>The requested <code class="docutils literal notranslate"><span class="pre">filepath</span></code> matches a cached entry</p></li>
<li><p>The requested <code class="docutils literal notranslate"><span class="pre">frame_id</span></code> satisfies: <code class="docutils literal notranslate"><span class="pre">first_frame_id</span> <span class="pre">&lt;=</span> <span class="pre">frame_id</span> <span class="pre">&lt;</span> <span class="pre">first_frame_id</span> <span class="pre">+</span> <span class="pre">gop_len</span></code></p></li>
</ul>
<p>If the <code class="docutils literal notranslate"><span class="pre">frame_id</span></code> is outside the cached GOP range, a new GOP is fetched and the cache is updated.</p>
<p><strong>Checking Cache Hit Status</strong></p>
<p>Use the <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit" title="accvlab.on_demand_video_decoder.CachedGopDecoder.isCacheHit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isCacheHit()</span></code></a> method to check whether the last <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> or <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a> call hit the cache:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Call GetGOP with caching</span>
<span class="n">packets</span><span class="p">,</span> <span class="n">first_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">,</span> <span class="n">frame_ids</span><span class="p">,</span> <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Check cache hit status for each video</span>
<span class="n">cache_hits</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">isCacheHit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cache_hits</span><span class="p">)</span>  <span class="c1"># [True, False, True, True, False] - per-video cache hit status</span>
</pre></div>
</div>
<p>The return value is a list of booleans, one for each video in the request, indicating whether the cached
data was used (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or new data was fetched (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p><strong>Cache Management Methods</strong></p>
<p>The decoder provides methods to manage the cache:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.get_cache_info" title="accvlab.on_demand_video_decoder.CachedGopDecoder.get_cache_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cache_info()</span></code></a></p></td>
<td><p>Returns a dictionary with cache statistics</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.clear_cache" title="accvlab.on_demand_video_decoder.CachedGopDecoder.clear_cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_cache()</span></code></a></p></td>
<td><p>Clears all cached GOP data</p></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get cache information</span>
<span class="n">cache_info</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">get_cache_info</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cached files: </span><span class="si">{</span><span class="n">cache_info</span><span class="p">[</span><span class="s1">&#39;cached_files_count&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File paths: </span><span class="si">{</span><span class="n">cache_info</span><span class="p">[</span><span class="s1">&#39;cached_files&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Clear all cache when done</span>
<span class="n">decoder</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>GOP Caching with GetGOPList</strong></p>
<p>The caching feature works identically with <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># First call - all videos are fetched</span>
<span class="n">gop_list</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOPList</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">,</span> <span class="p">[</span><span class="mi">77</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">77</span><span class="p">],</span> <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">isCacheHit</span><span class="p">())</span>  <span class="c1"># [False, False, False]</span>

<span class="c1"># Second call with some frame_ids in range, some out of range</span>
<span class="n">gop_list</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOPList</span><span class="p">(</span><span class="n">file_path_list</span><span class="p">,</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">isCacheHit</span><span class="p">())</span>  <span class="c1"># [True, True, False] - partial cache hit</span>
</pre></div>
</div>
<p><strong>Shared Cache Between GetGOP and GetGOPList</strong></p>
<p>The cache is shared between <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a> and <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList" title="accvlab.on_demand_video_decoder.CachedGopDecoder.GetGOPList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOPList()</span></code></a> calls on the same decoder instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Cache populated via GetGOP</span>
<span class="n">packets</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">([</span><span class="s2">&quot;/path/to/video.mp4&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Cache hit via GetGOPList (same file, frame_id in range)</span>
<span class="n">gop_list</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOPList</span><span class="p">([</span><span class="s2">&quot;/path/to/video.mp4&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">55</span><span class="p">],</span> <span class="n">useGOPCache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">isCacheHit</span><span class="p">())</span>  <span class="c1"># [True]</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>⚠️ Note</strong>: The cache is stored in Python memory. Each video file caches only one GOP (the most
recently accessed). For long-running processes with many different videos, use <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.CachedGopDecoder.clear_cache" title="accvlab.on_demand_video_decoder.CachedGopDecoder.clear_cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_cache()</span></code></a> to
release memory when needed.</p>
</div></blockquote>
<p><strong>When to Use GOP Caching</strong></p>
<p>✓ Training loops with random frame sampling from the same video
✓ Multi-camera setups where cameras are often accessed with similar frame indices
✓ Scenarios where the same GOP is likely to be accessed multiple times
✓ Reducing I/O overhead in data loading pipelines</p>
<p>✗ One-time video processing (no repeated access)
✗ Memory-constrained environments with large video collections
✗ Scenarios where each frame access targets a different GOP</p>
</section>
</section>
<section id="demuxer-free-decoding">
<h3>3.4 Demuxer-Free Decoding<a class="headerlink" href="#demuxer-free-decoding" title="Link to this heading"></a></h3>
<p>Demuxer-Free mode allows decoding directly from pre-extracted GOP data, either stored on disk or in memory. This approach is ideal for scenarios requiring repeated access to the same video segments.</p>
<section id="id3">
<h4>3.4.1 Use Cases<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Pre-processing video datasets for training</p></li>
<li><p>Repeated access to same video segments</p></li>
<li><p>Disk storage for GOP data caching</p></li>
<li><p>Eliminating demuxing overhead in production</p></li>
<li><p>PyTorch DataLoader integration with worker processes</p></li>
</ul>
</section>
<section id="sample-gop-file-storage-and-decoding">
<h4>3.4.2 Sample: GOP File Storage and Decoding<a class="headerlink" href="#sample-gop-file-storage-and-decoding" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleDecodeFromGopFiles.py</span></code></p>
<p><strong>Two-Phase Workflow</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Phase 1: GOP Data Preparation
Video Files → GetGOP() → SavePacketsToFile() → .bin files on disk

Phase 2: Decoding from Files
.bin files → LoadGops() → DecodeFromGOPRGB() → Decoded Frames
</pre></div>
</div>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a>: Extract GOP packet data</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.SavePacketsToFile" title="accvlab.on_demand_video_decoder.SavePacketsToFile"><code class="xref py py-func docutils literal notranslate"><span class="pre">SavePacketsToFile()</span></code></a>: Save packets to binary file</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGops()</span></code></a>: Load packets from binary files (merged)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPRGB()</span></code></a>: Decode from loaded packets</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize decoders:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Decoder for packet extraction</span>
<span class="n">nv_gop_dec1</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Decoder for GOP file decoding</span>
<span class="n">nv_gop_dec2</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Phase 1 - Extract and save GOP data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="c1"># ... more files</span>
<span class="p">]</span>

<span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">))]</span>
<span class="n">packet_files</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)):</span>
    <span class="c1"># Extract packet data for single file</span>
    <span class="n">numpy_data</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">nv_gop_dec1</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
        <span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    
    <span class="c1"># Save to binary file</span>
    <span class="n">packet_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./gop_packets_</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">.bin&quot;</span>
    <span class="n">nvc</span><span class="o">.</span><span class="n">SavePacketsToFile</span><span class="p">(</span><span class="n">numpy_data</span><span class="p">,</span> <span class="n">packet_file</span><span class="p">)</span>
    <span class="n">packet_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet_file</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved GOP data: </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">packet_file</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Phase 2 - Load and decode from GOP files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load stored GOP data</span>
<span class="n">merged_numpy_data</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">LoadGops</span><span class="p">(</span><span class="n">packet_files</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded GOP data: </span><span class="si">{</span><span class="n">merged_numpy_data</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>

<span class="c1"># Decode frames from loaded data</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPRGB</span><span class="p">(</span>
    <span class="n">merged_numpy_data</span><span class="p">,</span>  <span class="c1"># Merged packet data from LoadGops</span>
    <span class="n">file_list</span><span class="p">,</span>          <span class="c1"># Original video file paths</span>
    <span class="n">frames</span><span class="p">,</span>             <span class="c1"># Target frame indices</span>
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Cleanup temporary files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">packet_file</span> <span class="ow">in</span> <span class="n">packet_files</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">packet_file</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">packet_file</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>File Format</strong></p>
<p>GOP files are binary files containing raw packet data. The format is:</p>
<ul class="simple">
<li><p>Binary format (no header)</p></li>
<li><p>Direct memory dump of packet data</p></li>
<li><p>File extension: <code class="docutils literal notranslate"><span class="pre">.bin</span></code> (recommended)</p></li>
</ul>
<p><strong>Storage Considerations</strong></p>
<ul class="simple">
<li><p>GOP file size: Typically 5-15% of original video size</p></li>
<li><p>Storage savings: ~85-95% compared to extracted frames</p></li>
<li><p>I/O performance: SSD recommended for best performance</p></li>
</ul>
<p><strong>When to Use</strong></p>
<p>Use GOP file storage when:</p>
<ul class="simple">
<li><p>Same video segments accessed repeatedly</p></li>
<li><p>Training multiple epochs on the same dataset</p></li>
<li><p>Storage is cheaper than compute</p></li>
<li><p>Want to eliminate demuxing overhead</p></li>
</ul>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleDecodeFromGopFiles.py
</pre></div>
</div>
</section>
<section id="sample-gop-file-list-api">
<h4>3.4.3 Sample: GOP File List API<a class="headerlink" href="#sample-gop-file-list-api" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleDecodeFromGopFilesToListAPI.py</span></code></p>
<p><strong>When to Use</strong></p>
<p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGopsToList()</span></code></a> is preferred over
<a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGops()</span></code></a> when:</p>
<ul class="simple">
<li><p>Large video collections (&gt;10 videos)</p></li>
<li><p>Need selective loading of specific videos</p></li>
<li><p>Per-video cache management</p></li>
<li><p>Distributed caching systems</p></li>
</ul>
<p><strong>Core Difference: <a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGops()</span></code></a> vs</strong>
<strong><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGopsToList()</span></code></a></strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGops()</span></code></a></p></th>
<th class="head"><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGopsToList()</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return type</p></td>
<td><p>Single merged numpy array</p></td>
<td><p>List of numpy arrays (one per video)</p></td>
</tr>
<tr class="row-odd"><td><p>Loading</p></td>
<td><p>All or nothing</p></td>
<td><p>Selective loading possible</p></td>
</tr>
<tr class="row-even"><td><p>Memory usage</p></td>
<td><p>Load all GOP data at once</p></td>
<td><p>Load only needed videos</p></td>
</tr>
<tr class="row-odd"><td><p>Decoding API</p></td>
<td><p>DecodeFromGOPRGB</p></td>
<td><p>DecodeFromGOPListRGB</p></td>
</tr>
<tr class="row-even"><td><p>Best for</p></td>
<td><p>Small video sets</p></td>
<td><p>Large video collections</p></td>
</tr>
</tbody>
</table>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.SavePacketsToFile" title="accvlab.on_demand_video_decoder.SavePacketsToFile"><code class="xref py py-func docutils literal notranslate"><span class="pre">SavePacketsToFile()</span></code></a>: Save per-video GOP data</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.LoadGopsToList"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadGopsToList()</span></code></a>: Load GOP files as list (not
merged)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a>: Decode from list of GOP
data</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Phase 1 - Save per-video GOP files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_RIGHT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_FRONT_RIGHT.mp4&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">camera_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CAM_BACK_LEFT&quot;</span><span class="p">,</span> <span class="s2">&quot;CAM_BACK&quot;</span><span class="p">,</span> <span class="s2">&quot;CAM_BACK_RIGHT&quot;</span><span class="p">,</span>
                <span class="s2">&quot;CAM_FRONT_LEFT&quot;</span><span class="p">,</span> <span class="s2">&quot;CAM_FRONT&quot;</span><span class="p">,</span> <span class="s2">&quot;CAM_FRONT_RIGHT&quot;</span><span class="p">]</span>

<span class="n">packet_files</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">))]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)):</span>
    <span class="c1"># Extract GOP data for single video</span>
    <span class="n">numpy_data</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">nv_gop_dec1</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
        <span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    
    <span class="c1"># Create unique filename per video</span>
    <span class="n">packet_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./gop_</span><span class="si">{</span><span class="n">camera_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.bin&quot;</span>
    <span class="n">nvc</span><span class="o">.</span><span class="n">SavePacketsToFile</span><span class="p">(</span><span class="n">numpy_data</span><span class="p">,</span> <span class="n">packet_file</span><span class="p">)</span>
    <span class="n">packet_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Phase 2 - Load all GOP files as list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load GOP files as separate bundles (not merged)</span>
<span class="n">gop_data_list</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">LoadGopsToList</span><span class="p">(</span><span class="n">packet_files</span><span class="p">)</span>

<span class="c1"># gop_data_list is a list of numpy arrays, one per video</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gop_data_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> GOP bundles&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gop_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gop_data_list</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Bundle </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">camera_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gop_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Decode from GOP list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Decode all videos</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPListRGB</span><span class="p">(</span>
    <span class="n">gop_data_list</span><span class="p">,</span>  <span class="c1"># List of GOP data</span>
    <span class="n">file_list</span><span class="p">,</span>      <span class="c1"># List of file paths</span>
    <span class="n">frames</span><span class="p">,</span>         <span class="c1"># List of frame IDs</span>
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Phase 3 - Selective loading demonstration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select only front cameras (indices 3, 4, 5)</span>
<span class="n">selected_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">selected_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">packet_files</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">]</span>
<span class="n">selected_video_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">]</span>
<span class="n">selected_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">]</span>

<span class="c1"># Load only selected GOP files</span>
<span class="n">selected_gop_list</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">LoadGopsToList</span><span class="p">(</span><span class="n">selected_files</span><span class="p">)</span>

<span class="c1"># Decode only selected videos</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPListRGB</span><span class="p">(</span>
    <span class="n">selected_gop_list</span><span class="p">,</span>
    <span class="n">selected_video_paths</span><span class="p">,</span>
    <span class="n">selected_frames</span><span class="p">,</span>
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded and decoded only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">packet_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> videos&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Key Advantages</strong></p>
<ol class="arabic simple">
<li><p>Memory efficiency: Load only needed videos</p></li>
<li><p>Flexible loading: Different subsets for different batches</p></li>
<li><p>Distributed caching: Store videos on different machines</p></li>
<li><p>Per-video cache management: Independent expiration policies</p></li>
</ol>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleDecodeFromGopFilesToListAPI.py
</pre></div>
</div>
</section>
<section id="sample-batch-decode-from-multiple-demux-results">
<h4>3.4.4 Sample: Batch Decode from Multiple Demux Results<a class="headerlink" href="#sample-batch-decode-from-multiple-demux-results" title="Link to this heading"></a></h4>
<p><strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">packages/on_demand_video_decoder/samples/SampleDecodeFromGopList.py</span></code></p>
<p><strong>When to Use</strong></p>
<p>This sample demonstrates the pattern of multiple demuxing operations followed by a single batch decode:</p>
<ul class="simple">
<li><p>Demux executed N times separately (e.g., in DataLoader <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, called batch_size times)</p></li>
<li><p>Decode executed once for the entire batch</p></li>
<li><p>Enables parallel demuxing in worker processes, centralized batch decoding in main process</p></li>
<li><p>No disk I/O for GOP data (in-memory packet passing)</p></li>
</ul>
<p><strong>Architecture: N Demux → 1 Batch Decode</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Worker/Process 1: Video File 1 → GetGOP() → packets_1 (in memory)
Worker/Process 2: Video File 2 → GetGOP() → packets_2 (in memory)
Worker/Process 3: Video File 3 → GetGOP() → packets_3 (in memory)
                     ⋮                            ⋮
Worker/Process N: Video File N → GetGOP() → packets_N (in memory)
                                                      ↓
                          Collect all packets: [packets_1, packets_2, ..., packets_N]
                                                      ↓
                  Main Process: DecodeFromGOPListRGB() → Batch of N Frames (single decode call)
</pre></div>
</div>
<p><strong>Core Concept</strong></p>
<p>Multiple separate demuxing operations → Single batch decoding operation</p>
<p><strong>Core APIs</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.GetGOP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetGOP()</span></code></a>: Extract packets (called N times,
possibly in parallel)</p></li>
<li><p><a class="reference internal" href="api.html#accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB" title="accvlab.on_demand_video_decoder.PyNvGopDecoder.DecodeFromGOPListRGB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DecodeFromGOPListRGB()</span></code></a>: Batch decode from list of
packets (called once for entire batch)</p></li>
</ul>
<p><strong>Code Walkthrough</strong></p>
<p>Initialize decoders:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Worker decoder (simulated): for packet extraction</span>
<span class="n">nv_gop_dec1</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Main process decoder: for batch decoding</span>
<span class="n">nv_gop_dec2</span> <span class="o">=</span> <span class="n">nvc</span><span class="o">.</span><span class="n">CreateGopDecoder</span><span class="p">(</span><span class="n">maxfiles</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">iGpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Phase 1 - Multiple demux operations (simulating parallel workers):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;/data/videos/CAM_BACK_LEFT.mp4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;/data/videos/CAM_BACK.mp4&quot;</span><span class="p">,</span>
    <span class="c1"># ... more files</span>
<span class="p">]</span>

<span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">))]</span>

<span class="c1"># Demux executed N times (e.g., in DataLoader __getitem__, called batch_size times)</span>
<span class="n">packets_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)):</span>
    <span class="c1"># Each demux operation extracts packets for one video</span>
    <span class="n">numpy_data</span><span class="p">,</span> <span class="n">first_frame_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">nv_gop_dec1</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">(</span>
        <span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">packets_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy_data</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Demux </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Extracted </span><span class="si">{</span><span class="n">numpy_data</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Phase 2 - Single batch decode (in main process):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Decode executed once for all N demux results</span>
<span class="n">decoded_frames</span> <span class="o">=</span> <span class="n">nv_gop_dec2</span><span class="o">.</span><span class="n">DecodeFromGOPListRGB</span><span class="p">(</span>
    <span class="n">packets_list</span><span class="p">,</span>  <span class="c1"># List of N packet data from multiple demux operations</span>
    <span class="n">file_list</span><span class="p">,</span>     <span class="c1"># Original file paths</span>
    <span class="n">frames</span><span class="p">,</span>        <span class="c1"># Target frame IDs</span>
    <span class="n">as_bgr</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch decode: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">decoded_frames</span><span class="p">)</span><span class="si">}</span><span class="s2"> frames decoded in one call&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>DataLoader Integration Pattern</strong></p>
<p>In a real PyTorch DataLoader:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In worker process (worker_fn)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">worker_fn</span><span class="p">(</span><span class="n">video_path</span><span class="p">,</span> <span class="n">frame_id</span><span class="p">):</span>
    <span class="n">packets</span><span class="p">,</span> <span class="n">first_ids</span><span class="p">,</span> <span class="n">gop_lens</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">GetGOP</span><span class="p">([</span><span class="n">video_path</span><span class="p">],</span> <span class="p">[</span><span class="n">frame_id</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">packets</span>

<span class="c1"># In main process collate_fn</span>
<span class="k">def</span><span class="w"> </span><span class="nf">collate_fn</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
    <span class="n">packets_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;file_path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
    <span class="n">frame_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;frame_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
    
    <span class="c1"># Batch decode in main process</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">DecodeFromGOPListRGB</span><span class="p">(</span><span class="n">packets_list</span><span class="p">,</span> <span class="n">file_paths</span><span class="p">,</span> <span class="n">frame_ids</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frames</span>
</pre></div>
</div>
<p><strong>Key Benefits</strong></p>
<ol class="arabic simple">
<li><p><strong>Parallel demuxing</strong>: Each worker demuxes independently in parallel</p></li>
<li><p><strong>Single batch decode</strong>: GPU decoder called only once for entire batch (efficient GPU utilization)</p></li>
<li><p><strong>No disk I/O</strong>: Packets passed in memory, no temporary file storage</p></li>
<li><p><strong>Resource separation</strong>: CPU-heavy demuxing in workers, GPU decoding in main process</p></li>
</ol>
<p><strong>Memory Management</strong></p>
<ul class="simple">
<li><p>Keep packet data lifetime short (decode and release)</p></li>
<li><p>Monitor memory usage in worker processes</p></li>
<li><p>Balance worker count with available memory</p></li>
</ul>
<p><strong>Running the Sample</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>packages/on_demand_video_decoder/samples
python<span class="w"> </span>SampleDecodeFromGopList.py
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pytorch_integration_examples/index.html" class="btn btn-neutral float-right" title="PyTorch Integration Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, NVIDIA Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>